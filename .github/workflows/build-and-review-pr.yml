name: Build and Review PR
run-name: 'Build and Review PR #${{ github.event.pull_request.number }}'

on:
  # https://docs.github.com/en/actions/security-guides/automatic-token-authentication#permissions-for-the-github_token
  #
  # This workflow uses the pull_request trigger which prevents write permissions on the
  # GH_TOKEN and secrets access from public forks.  This should remain as a pull_request
  # trigger to minimize the access public forks have in the repository.  The reduced
  # permissions are adequate but do mean that re-compiles and readme changes will have to be
  # made manually by the PR author.  These auto-updates could be done by this workflow
  # for branches but in order to re-trigger a PR build (which is needed for status checks),
  # we would make the commits with a different user and their PAT.  To minimize exposure
  # and complication we will request those changes be manually made by the PR author.
  pull_request:
    types: [opened, synchronize, reopened]
  # paths:
  #   Do not include specific paths here.  We always want this build to run and produce a
  #   status check which are branch protection rules can use.  If this is skipped because of
  #   path filtering, a status check will not be created and we won't be able to merge the PR
  #   without disabling that requirement.  If we have a status check that is always produced,
  #   we can also use that to require all branches be up to date before they are merged.

jobs:
  build-and-review-pr:
    # This reusable workflow will check to see if an action's source code has changed based on
    # whether the PR includes files that match the files-with-code arg or are in one of the
    # dirs-with-code directories.  If there are source code changes, this reusable workflow
    # will then run the action's build (if one was provided) and update the README.md with the
    # the latest version of the action.  If those two steps result in any changes that need to
    # be committed, the workflow will fail because the PR needs some updates.  Instructions for
    # updating the PR will be available in the build log, the workflow summary and as a PR
    # comment if the PR came from a branch (not a fork).
    # This workflow assumes:
    #  - The main README.md is at the root of the repo
    #  - The README contains a contribution guidelines and usage examples section
    uses: im-open/.github/.github/workflows/reusable-build-and-review-pr.yml@v1
    with:
      action-name: ${{ github.repository }}
      default-branch: main
      readme-name: 'README.md'

      # The id of the contribution guidelines section of the README.md
      readme-contribution-id: '#contributing'

      # The id of the usage examples section of the README.md
      readme-examples-id: '#usage-examples'

      # The files that contain source code for the action.  Only files that affect the action's execution
      # should be included like action.yml or package.json.  Do not include files like README.md or .gitignore.
      # Files do not need to be explicitly provided here if they fall under one of the dirs in dirs-with-code.
      # ** This value must match the same files-with-code argument specified in increment-version-on-merge.yml.
      files-with-code: 'action.yml,package.json,package-lock.json'

      # The directories that contain source code for the action.  Only dirs with files that affect the action's
      # execution should be included like src or dist.  Do not include dirs like .github or node_modules.
      # ** This value must match the same dirs-with-code argument specified in increment-version-on-merge.yml.
      dirs-with-code: 'src,dist'

      # The npm script to run to build the action.  This is typically 'npm run build' if the
      # action needs to be compiled.  For composite-run-steps actions this is typically empty.
      build-command: 'npm run build'

  unit-tests:
    runs-on: ubuntu-latest
    env:
      DIR_WITH_NO_TRX: './test/files/dir-with-no-trx-files'

    steps:
      - name: '-------------------------------------------------------------------------------------------------------------'
        run: echo ""
      - name: '                                                    SETUP                                                    '
        run: echo ""

      - name: Setup - Checkout the action
        uses: actions/checkout@v4

      - name: Setup - Create empty directory
        run: mkdir -p ${{ env.DIR_WITH_NO_TRX }}

      - name: '-------------------------------------------------------------------------------------------------------------'
        run: echo ""
      - name: '                                        TEST 1 - MISSING TOKEN INPUT                                         '
        run: echo ""

      - name: 1a - When process-dotnet-test-results is called with a missing github-token input
        id: missing-github-token
        if: always()
        continue-on-error: true # This is needed because we expect the step to fail but we need it to "pass" in order for the test job to succeed.
        uses: ./
        with:
          github-token: ''
          base-directory: './test/files/single-test'

      - name: 1b - Then the action outcome should be failure
        if: always()
        run: ./test/assert-values-match.sh --name "step outcome" --expected "failure" --actual "${{ steps.missing-github-token.outcome }}"

      - name: 1c - And each of the outputs should be empty
        if: always()
        run: |
          ./test/assert-value-is-empty.sh --name "test-outcome output" --value "${{ steps.missing-github-token.outputs.test-outcome }}"
          ./test/assert-value-is-empty.sh --name "trx-files output" --value "${{ steps.missing-github-token.outputs.trx-files }}"
          ./test/assert-value-is-empty.sh --name "test-results-truncated output" --value "${{ steps.missing-github-token.outputs.test-results-truncated }}"
          ./test/assert-value-is-empty.sh --name "test-results-file-path output" --value "${{ steps.missing-github-token.outputs.test-results-file-path }}"
          ./test/assert-value-is-empty.sh --name "status-check-ids output" --value "${{ steps.missing-github-token.outputs.status-check-ids }}"
          ./test/assert-value-is-empty.sh --name "pr-comment-id output" --value "${{ steps.missing-github-token.outputs.pr-comment-id }}"

      - name: '-------------------------------------------------------------------------------------------------------------'
        run: echo ""
      - name: '                                            TEST 2 - NO TRX FILES                                            '
        run: echo ""

      - name: 2a - When process-dotnet-test-results is called with a base-directory that does not contain trx files
        if: always()
        id: range-error
        continue-on-error: true # This is needed because we expect the step to fail but we need it to "pass" in order for the test job to succeed.
        uses: ./
        with:
          github-token: '${{ secrets.GITHUB_TOKEN }}'
          base-directory: '${{ env.DIR_WITH_NO_TRX }}'

      - name: 2b - Then the action outcome should be success
        if: always()
        run: ./test/assert-values-match.sh --name "step outcome" --expected "success" --actual "${{ steps.range-error.outcome }}"

      - name: 2c - And the other outputs should indicate a failure happened
        if: always()
        run: |
          ./test/assert-values-match.sh --name "test-outcome output" --expected "Failed" --actual "${{ steps.range-error.outputs.test-outcome }}"
          ./test/assert-value-is-empty.sh --name "test-results-file-path output" --value "${{ steps.range-error.outputs.test-results-file-path }}"
          ./test/assert-value-is-empty.sh --name "trx-files output" --value "${{ steps.range-error.outputs.trx-files }}"
          ./test/assert-value-is-empty.sh --name "test-results-truncated output" --value "${{ steps.range-error.outputs.test-results-truncated }}"
          ./test/assert-value-is-empty.sh --name "status-check-ids output" --value "${{ steps.range-error.outputs.status-check-ids }}"
          ./test/assert-value-is-empty.sh --name "pr-comment-id output" --value "${{ steps.range-error.outputs.pr-comment-id }}"

      - name: '-------------------------------------------------------------------------------------------------------------'
        run: echo ""
      - name: '                                           TEST 3 - MALFORMED TRX                                            '
        run: echo ""

      - name: 3a - When process-dotnet-test-results is called to process a malformed trx file (invalid xml)
        if: always()
        id: malformed-xml
        continue-on-error: true # This is needed because we expect the step to fail but we need it to "pass" in order for the test job to succeed.
        uses: ./
        with:
          github-token: ${{ secrets.GITHUB_TOKEN }}
          base-directory: './test/files/malformed-xml'

      - name: 3b - Then the action outcome should be failure
        if: always()
        run: ./test/assert-values-match.sh --name "step outcome" --expected "failure" --actual "${{ steps.malformed-xml.outcome }}"

      - name: 3c - And the other outputs should indicate a failure happened
        if: always()
        run: |
          ./test/assert-values-match.sh --name "test-outcome output" --expected "Failed" --actual "${{ steps.malformed-xml.outputs.test-outcome }}"
          ./test/assert-value-is-empty.sh --name "test-results-file-path output" --value "${{ steps.malformed-xml.outputs.test-results-file-path }}"
          ./test/assert-value-is-empty.sh --name "trx-files output" --value "${{ steps.malformed-xml.outputs.trx-files }}"
          ./test/assert-value-is-empty.sh --name "test-results-truncated output" --value "${{ steps.malformed-xml.outputs.test-results-truncated }}"
          ./test/assert-value-is-empty.sh --name "status-check-ids output" --value "${{ steps.malformed-xml.outputs.status-check-ids }}"
          ./test/assert-value-is-empty.sh --name "pr-comment-id output" --value "${{ steps.malformed-xml.outputs.pr-comment-id }}"

      - name: '-------------------------------------------------------------------------------------------------------------'
        run: echo ""
      - name: '                                          TEST 4 - MISSING TestRun                                           '
        run: echo ""

      - name: 4a - When process-dotnet-test-results is called with a trx file that is missing the TestRun node
        if: always()
        id: missing-testrun
        continue-on-error: true # This is needed because we expect the step to fail but we need it to "pass" in order for the test job to succeed.
        uses: ./
        with:
          github-token: '${{ secrets.GITHUB_TOKEN }}'
          base-directory: './test/files/missing-testrun'

      - name: 4b - Then the action outcome should be failure
        if: always()
        run: ./test/assert-values-match.sh --name "step outcome" --expected "failure" --actual "${{ steps.missing-testrun.outcome }}"

      - name: 4c - And the other outputs should indicate a failure happened
        if: always()
        run: |
          ./test/assert-values-match.sh --name "test-outcome output" --expected "Failed" --actual "${{ steps.missing-testrun.outputs.test-outcome }}"
          ./test/assert-value-is-empty.sh --name "test-results-file-path output" --value "${{ steps.missing-testrun.outputs.test-results-file-path }}"
          ./test/assert-value-is-empty.sh --name "trx-files output" --value "${{ steps.missing-testrun.outputs.trx-files }}"
          ./test/assert-value-is-empty.sh --name "test-results-truncated output" --value "${{ steps.missing-testrun.outputs.test-results-truncated }}"
          ./test/assert-value-is-empty.sh --name "status-check-ids output" --value "${{ steps.missing-testrun.outputs.status-check-ids }}"
          ./test/assert-value-is-empty.sh --name "pr-comment-id output" --value "${{ steps.missing-testrun.outputs.pr-comment-id }}"

      - name: '-------------------------------------------------------------------------------------------------------------'
        run: echo ""
      - name: '                                    TEST 5 - MISSING TestRun.ResultSummary                                   '
        run: echo ""

      - name: 5a - When process-dotnet-test-results is called with a trx file that is missing the TestRun.ResultSummary node
        if: always()
        id: missing-resultsummary
        continue-on-error: true # This is needed because we expect the step to fail but we need it to "pass" in order for the test job to succeed.
        uses: ./
        with:
          github-token: '${{ secrets.GITHUB_TOKEN }}'
          base-directory: './test/files/missing-resultsummary'

      - name: 5b - Then the action outcome should be failure
        if: always()
        run: ./test/assert-values-match.sh --name "step outcome" --expected "failure" --actual "${{ steps.missing-resultsummary.outcome }}"

      - name: 5c - And the other outputs should indicate a failure happened
        if: always()
        run: |
          ./test/assert-values-match.sh --name "test-outcome output" --expected "Failed" --actual "${{ steps.missing-resultsummary.outputs.test-outcome }}"
          ./test/assert-value-is-empty.sh --name "test-results-file-path output" --value "${{ steps.missing-resultsummary.outputs.test-results-file-path }}"
          ./test/assert-value-is-empty.sh --name "trx-files output" --value "${{ steps.missing-resultsummary.outputs.trx-files }}"
          ./test/assert-value-is-empty.sh --name "test-results-truncated output" --value "${{ steps.missing-resultsummary.outputs.test-results-truncated }}"
          ./test/assert-value-is-empty.sh --name "status-check-ids output" --value "${{ steps.missing-resultsummary.outputs.status-check-ids }}"
          ./test/assert-value-is-empty.sh --name "pr-comment-id output" --value "${{ steps.missing-resultsummary.outputs.pr-comment-id }}"

      - name: '-------------------------------------------------------------------------------------------------------------'
        run: echo ""
      - name: '                               TEST 6 - MISSING TestRun.ResultSummary.Counters                               '
        run: echo ""

      - name: 6a - When process-dotnet-test-results is called with a trx file that is missing the TestRun.ResultSummary.Counters node
        if: always()
        id: missing-counters
        continue-on-error: true # This is needed because we expect the step to fail but we need it to "pass" in order for the test job to succeed.
        uses: ./
        with:
          github-token: '${{ secrets.GITHUB_TOKEN }}'
          base-directory: './test/files/missing-counters'

      - name: 6b - Then the action outcome should be failure
        if: always()
        run: ./test/assert-values-match.sh --name "step outcome" --expected "failure" --actual "${{ steps.missing-counters.outcome }}"

      - name: 6c - And the other outputs should indicate a failure happened
        if: always()
        run: |
          ./test/assert-values-match.sh --name "test-outcome output" --expected "Failed" --actual "${{ steps.missing-counters.outputs.test-outcome }}"
          ./test/assert-value-is-empty.sh --name "test-results-file-path output" --value "${{ steps.missing-counters.outputs.test-results-file-path }}"
          ./test/assert-value-is-empty.sh --name "trx-files output" --value "${{ steps.missing-counters.outputs.trx-files }}"
          ./test/assert-value-is-empty.sh --name "test-results-truncated output" --value "${{ steps.missing-counters.outputs.test-results-truncated }}"
          ./test/assert-value-is-empty.sh --name "status-check-ids output" --value "${{ steps.missing-counters.outputs.status-check-ids }}"
          ./test/assert-value-is-empty.sh --name "pr-comment-id output" --value "${{ steps.missing-counters.outputs.pr-comment-id }}"

      - name: '-------------------------------------------------------------------------------------------------------------'
        run: echo ""
      - name: '                               TEST 7 - MISSING TestRun.ResultSummary.RunInfos                               '
        run: echo ""

      - name: 7a - When process-dotnet-test-results is called with a trx file that is missing the TestRun.ResultSummary.RunInfos node
        if: always()
        id: missing-runinfos
        continue-on-error: true # This is needed because we expect the step to fail but we need it to "pass" in order for the test job to succeed.
        uses: ./
        with:
          github-token: '${{ secrets.GITHUB_TOKEN }}'
          base-directory: './test/files/missing-runinfos'

      - name: 7b - Then the action outcome should be failure
        if: always()
        run: ./test/assert-values-match.sh --name "step outcome" --expected "failure" --actual "${{ steps.missing-runinfos.outcome }}"

      - name: 7c - And the other outputs should indicate a failure happened
        if: always()
        run: |
          ./test/assert-values-match.sh --name "test-outcome output" --expected "Failed" --actual "${{ steps.missing-runinfos.outputs.test-outcome }}"
          ./test/assert-value-is-empty.sh --name "test-results-file-path output" --value "${{ steps.missing-runinfos.outputs.test-results-file-path }}"
          ./test/assert-value-is-empty.sh --name "trx-files output" --value "${{ steps.missing-runinfos.outputs.trx-files }}"
          ./test/assert-value-is-empty.sh --name "test-results-truncated output" --value "${{ steps.missing-runinfos.outputs.test-results-truncated }}"
          ./test/assert-value-is-empty.sh --name "status-check-ids output" --value "${{ steps.missing-runinfos.outputs.status-check-ids }}"
          ./test/assert-value-is-empty.sh --name "pr-comment-id output" --value "${{ steps.missing-runinfos.outputs.pr-comment-id }}"

      - name: '-------------------------------------------------------------------------------------------------------------'
        run: echo ""
      - name: '                           TEST 8 - MISSING TestRun.ResultSummary.RunInfos.RunInfo                           '
        run: echo ""

      - name: 8a - When process-dotnet-test-results is called with a trx file that is missing the TestRun.ResultSummary.RunInfos.RunInfo node
        if: always()
        id: missing-runinfo
        continue-on-error: true # This is needed because we expect the step to fail but we need it to "pass" in order for the test job to succeed.
        uses: ./
        with:
          github-token: '${{ secrets.GITHUB_TOKEN }}'
          base-directory: './test/files/missing-runinfo'

      - name: 8b - Then the action outcome should be failure
        if: always()
        run: ./test/assert-values-match.sh --name "step outcome" --expected "failure" --actual "${{ steps.missing-runinfo.outcome }}"

      - name: 8c - And the other outputs should indicate a failure happened
        if: always()
        run: |
          ./test/assert-values-match.sh --name "test-outcome output" --expected "Failed" --actual "${{ steps.missing-runinfo.outputs.test-outcome }}"
          ./test/assert-value-is-empty.sh --name "test-results-file-path output" --value "${{ steps.missing-runinfo.outputs.test-results-file-path }}"
          ./test/assert-value-is-empty.sh --name "trx-files output" --value "${{ steps.missing-runinfo.outputs.trx-files }}"
          ./test/assert-value-is-empty.sh --name "test-results-truncated output" --value "${{ steps.missing-runinfo.outputs.test-results-truncated }}"
          ./test/assert-value-is-empty.sh --name "status-check-ids output" --value "${{ steps.missing-runinfo.outputs.status-check-ids }}"
          ./test/assert-value-is-empty.sh --name "pr-comment-id output" --value "${{ steps.missing-runinfo.outputs.pr-comment-id }}"

      - name: '-------------------------------------------------------------------------------------------------------------'
        run: echo ""
      - name: '                                          TEST 9 - NO TESTS IN FILE                                          '
        run: echo ""

      - name: 9a - When process-dotnet-test-results is called with a file that does not contain test results or test definitions
        if: always()
        id: no-tests
        uses: ./
        with:
          github-token: '${{ secrets.GITHUB_TOKEN }}'
          base-directory: './test/files/no-tests'
          create-status-check: false
          create-pr-comment: false
          timezone: 'America/Denver'

      - name: 9b - Then the action outcome should be success
        if: always()
        run: ./test/assert-values-match.sh --name "step outcome" --expected "success" --actual "${{ steps.no-tests.outcome }}"

      - name: 9c - And the trx-files output should be contain the no-tests.trx file
        if: always()
        run: ./test/assert-values-match.sh --name "trx-files output" --expected "[./test/files/no-tests/no-tests.trx]" --actual "${{ steps.no-tests.outputs.trx-files }}"

      - name: 9d - And the test-outcome output should be Passed because there are no failing tests
        if: always()
        run: ./test/assert-values-match.sh --name "test-outcome output" --expected "Passed" --actual "${{ steps.no-tests.outputs.test-outcome }}"

      - name: 9e - And the 'test-results-file-path output' should be populated
        if: always()
        run: ./test/assert-value-is-not-empty.sh --name "test-results-file-path output" --value "${{ steps.no-tests.outputs.test-results-file-path }}"

      - name: 9f - And the other outputs should be empty because pr comments and status checks are not being created
        if: always()
        run: |
          ./test/assert-value-is-empty.sh --name "test-results-truncated output" --value "${{ steps.no-tests.outputs.test-results-truncated }}"
          ./test/assert-value-is-empty.sh --name "status-check-ids output" --value "${{ steps.no-tests.outputs.status-check-ids }}"
          ./test/assert-value-is-empty.sh --name "pr-comment-id output" --value "${{ steps.no-tests.outputs.pr-comment-id }}"

      - name: 9g - And the contents of ${{ steps.no-tests.outputs.test-results-file-path }} should match the expected markdown
        if: always()
        run: |
          # Comparing the test-results file will ensure that:
          #  - The correct timezone is used
          #  - The computer name is used for report title when there are no tests
          #  - The test icon is correct when the outcome doesn't match expected scenarios (passed/failed/notexecuted)
          #  - The Duration stats are included in the report
          #  - The Counter stats are included in the report

          expectedFileName="./test/files/no-tests/expected-test-results.md"
          actualFileName="${{ steps.no-tests.outputs.test-results-file-path }}"
          ./test/assert-file-contents-match.sh --expectedFileName $expectedFileName --actualFileName $actualFileName

      - name: '--------------------------------------------------------------------------------------------------------------'
        run: |
          echo ""
      - name: '                                       TEST 10 - NO UNIT TESTS IN FILE                                        '
        run: echo ""

      - name: 10a - When process-dotnet-test-results is called with a file that does not contain unit test results or unit test definitions
        if: always()
        id: no-unit-tests
        uses: ./
        with:
          github-token: '${{ secrets.GITHUB_TOKEN }}'
          base-directory: './test/files/no-unit-tests'
          create-status-check: false
          create-pr-comment: false

      - name: 10b - Then the action outcome should be success
        if: always()
        run: ./test/assert-values-match.sh --name "step outcome" --expected "success" --actual "${{ steps.no-unit-tests.outcome }}"

      - name: 10c - And the trx-files output should be contain the no-unit-tests.trx file
        if: always()
        run: ./test/assert-values-match.sh --name "trx-files output" --expected "[./test/files/no-unit-tests/no-unit-tests.trx]" --actual "${{ steps.no-unit-tests.outputs.trx-files }}"

      - name: 10d - And the test-outcome output should be Passed because there are no failing tests
        if: always()
        run: ./test/assert-values-match.sh --name "test-outcome output" --expected "Passed" --actual "${{ steps.no-unit-tests.outputs.test-outcome }}"

      - name: 10e - And the 'test-results-file-path output' should be populated
        if: always()
        run: ./test/assert-value-is-not-empty.sh --name "test-results-file-path output" --value "${{ steps.no-unit-tests.outputs.test-results-file-path }}"
          
      - name: 10f - And the other outputs should be empty because pr comments and status checks are not being created
        if: always()
        run: |
          ./test/assert-value-is-empty.sh --name "test-results-truncated output" --value "${{ steps.no-unit-tests.outputs.test-results-truncated }}"
          ./test/assert-value-is-empty.sh --name "status-check-ids output" --value "${{ steps.no-unit-tests.outputs.status-check-ids }}"
          ./test/assert-value-is-empty.sh --name "pr-comment-id output" --value "${{ steps.no-unit-tests.outputs.pr-comment-id }}"

      - name: 10g - And the contents of ${{ steps.no-unit-tests.outputs.test-results-file-path }} should match the expected markdown
        if: always()
        run: |
          # Comparing the test-results file will ensure that:
          #  - The default timezone is used
          #  - 'Not Found' is used for report title when there are no tests and no _computerName attr present
          #  - The Duration stats are included in the report
          #  - The Counter stats are included in the report

          expectedFileName="./test/files/no-unit-tests/expected-test-results.md"
          actualFileName="${{ steps.no-unit-tests.outputs.test-results-file-path }}"
          ./test/assert-file-contents-match.sh --expectedFileName $expectedFileName --actualFileName $actualFileName

      - name: '--------------------------------------------------------------------------------------------------------------'
        run: |
          echo ""

      - name: '                                            TEST 11 - SINGLE TEST                                             '
        run: echo ""

      - name: 11a - When process-dotnet-test-results is called with a file that reports a single test
        if: always()
        id: single-test
        uses: ./
        with:
          github-token: '${{ secrets.GITHUB_TOKEN }}'
          base-directory: './test/files/single-test'
          create-status-check: false
          create-pr-comment: false

      - name: 11b - Then the action outcome should be success
        if: always()
        run: ./test/assert-values-match.sh --name "step outcome" --expected "success" --actual "${{ steps.single-test.outcome }}"

      - name: 11c - And the outputs should indicate a success happened
        if: always()
        run: |
          # Verify the trx-files list matches what we expect
          ./test/assert-values-match.sh --name "trx-files output" --expected "[./test/files/single-test/single-test.trx]" --actual "${{ steps.single-test.outputs.trx-files }}"

          # Verify the test-outcome is passed
          ./test/assert-values-match.sh --name "test-outcome output" --expected "Passed" --actual "${{ steps.single-test.outputs.test-outcome }}"

          # Verify the test-results-file-path output should be populated
          ./test/assert-value-is-not-empty.sh --name "test-results-file-path output" --value "${{ steps.single-test.outputs.test-results-file-path }}"
          
          # Verify this output is not set because we aren't creating a PR comment or status check
          ./test/assert-value-is-empty.sh --name "test-results-truncated output" --value "${{ steps.single-test.outputs.test-results-truncated }}"
          ./test/assert-value-is-empty.sh --name "status-check-ids output" --value "${{ steps.single-test.outputs.status-check-ids }}"
          ./test/assert-value-is-empty.sh --name "pr-comment-id output" --value "${{ steps.single-test.outputs.pr-comment-id }}"

      - name: 11d - And the contents of ${{ steps.single-test.outputs.test-results-file-path }} should match the expected markdown
        if: always()
        run: |
          # Comparing the test-results file will ensure that:
          #  - The default timezone is used
          #  - The dll name is used for report title when a report title filter is not specified
          #  - The Duration stats are included in the report
          #  - The Counter stats are included in the report

          expectedFileName="./test/files/single-test/expected-test-results.md"
          actualFileName="${{ steps.single-test.outputs.test-results-file-path }}"
          ./test/assert-file-contents-match.sh --expectedFileName $expectedFileName --actualFileName $actualFileName

      - name: '--------------------------------------------------------------------------------------------------------------'
        run: |
          echo ""
      - name: '                                           TEST 12 - MULTIPLE TESTS                                           '
        run: echo ""

      - name: 12a - When process-dotnet-test-results is called with a file that has multiple tests and a report title filter
        if: always()
        id: multiple-tests
        uses: ./
        with:
          github-token: '${{ secrets.GITHUB_TOKEN }}'
          base-directory: './test/files/multiple-tests'
          create-status-check: false
          create-pr-comment: false
          report-title-filter: 'Tests'

      - name: 12b - Then the action outcome should be success
        if: always()
        run: ./test/assert-values-match.sh --name "step outcome" --expected "success" --actual "${{ steps.multiple-tests.outcome }}"

      - name: 12c - And the outputs should indicate a success happened
        if: always()
        run: |
          # Verify the trx-files list matches what we expect
          ./test/assert-values-match.sh --name "trx-files output" --expected "[./test/files/multiple-tests/multiple-tests.trx]" --actual "${{ steps.multiple-tests.outputs.trx-files }}"

          # Verify the test-outcome is passed
          ./test/assert-values-match.sh --name "test-outcome output" --expected "Passed" --actual "${{ steps.multiple-tests.outputs.test-outcome }}"

          # Verify the test-results-file-path output is populated
          ./test/assert-value-is-not-empty.sh --name "test-results-file-path output" --value "${{ steps.multiple-tests.outputs.test-results-file-path }}"
          
          # Verify this output is not set because we aren't creating a PR comment or status check
          ./test/assert-value-is-empty.sh --name "test-results-truncated output" --value "${{ steps.multiple-tests.outputs.test-results-truncated }}"
          ./test/assert-value-is-empty.sh --name "status-check-ids output" --value "${{ steps.multiple-tests.outputs.status-check-ids }}"
          ./test/assert-value-is-empty.sh --name "pr-comment-id output" --value "${{ steps.multiple-tests.outputs.pr-comment-id }}"

      - name: 12d - And the contents of ${{ steps.multiple-tests.outputs.test-results-file-path }} should match the expected markdown
        if: always()
        run: |
          # Comparing the test-results file will ensure that:
          #  - The default timezone is used
          #  - The report title is simplified when a report title filter is specified
          #  - The Duration stats are included in the report
          #  - The Counter stats are included in the report

          expectedFileName="./test/files/multiple-tests/expected-test-results.md"
          actualFileName="${{ steps.multiple-tests.outputs.test-results-file-path }}"
          ./test/assert-file-contents-match.sh --expectedFileName $expectedFileName --actualFileName $actualFileName

      - name: '--------------------------------------------------------------------------------------------------------------'
        run: |
          echo ""
      - name: '                                             TEST 13 - MULTIPLE TRX                                           '
        run: echo ""

      - name: 13a - When process-dotnet-test-results is called with multiple passing trx files
        if: always()
        id: multiple-trx
        uses: ./
        with:
          github-token: '${{ secrets.GITHUB_TOKEN }}'
          base-directory: './test/files/multiple-trx'
          create-status-check: false
          create-pr-comment: false

      - name: 13b - Then the action outcome should be success
        if: always()
        run: ./test/assert-values-match.sh --name "step outcome" --expected "success" --actual "${{ steps.multiple-trx.outcome }}"

      - name: 13c - And the outputs should indicate a success happened
        if: always()
        run: |
          # Verify the trx-files list matches what we expect
          trx1="./test/files/multiple-trx/trx1.trx"
          trx2="./test/files/multiple-trx/trx2.trx"
          ./test/assert-values-match.sh --name "trx-files output" --expected "[$trx1,$trx2]" --actual "${{ steps.multiple-trx.outputs.trx-files }}"

          # Verify the test-outcome is passed
          ./test/assert-values-match.sh --name "test-outcome output" --expected "Passed" --actual "${{ steps.multiple-trx.outputs.test-outcome }}"

          # Verify the test-results-file-path output is populated
          ./test/assert-value-is-not-empty.sh --name "test-results-file-path output" --value "${{ steps.multiple-trx.outputs.test-results-file-path }}"
          
          # Verify this output is not set because we aren't creating a PR comment or status check
          ./test/assert-value-is-empty.sh --name "test-results-truncated output" --value "${{ steps.multiple-trx.outputs.test-results-truncated }}"
          ./test/assert-value-is-empty.sh --name "pr-comment-id output" --value "${{ steps.multiple-trx.outputs.pr-comment-id }}"
          ./test/assert-value-is-empty.sh --name "status-check-ids output" --value "${{ steps.multiple-trx.outputs.status-check-ids }}"

      - name: 13d - And the contents of ${{ steps.multiple-trx.outputs.test-results-file-path }} should match the expected markdown
        if: always()
        run: |
          # Comparing the test-results file will ensure that:
          #  - The default timezone is used
          #  - The Duration stats are included in the report
          #  - The Counter stats are included in the report
          #  - There are multiple sections when multiple trx files are processed

          expectedFileName="./test/files/multiple-trx/expected-test-results.md"
          actualFileName="${{ steps.multiple-trx.outputs.test-results-file-path }}"
          ./test/assert-file-contents-match.sh --expectedFileName $expectedFileName --actualFileName $actualFileName

      - name: '--------------------------------------------------------------------------------------------------------------'
        run: |
          echo ""
      - name: '                                             TEST 14 - FAILING TEST                                           '
        run: echo ""

      - name: 14a - When process-dotnet-test-results is called with a failing trx file
        if: always()
        id: failing-test
        uses: ./
        with:
          github-token: '${{ secrets.GITHUB_TOKEN }}'
          base-directory: './test/files/failing-test-ignore'
          create-status-check: false
          create-pr-comment: false

      - name: 14b - Then the action outcome should be success
        if: always()
        run: ./test/assert-values-match.sh --name "step outcome" --expected "success" --actual "${{ steps.failing-test.outcome }}"

      - name: 14c - And the outputs should indicate a success happened
        if: always()
        run: |
          # Verify the trx-files list matches what we expect
          failure="./test/files/failing-test-ignore/failure.trx"
          ./test/assert-values-match.sh --name "trx-files output" --expected "[$failure]" --actual "${{ steps.failing-test.outputs.trx-files }}"

          # Verify the test-outcome is Failed
          ./test/assert-values-match.sh --name "test-outcome output" --expected "Failed" --actual "${{ steps.failing-test.outputs.test-outcome }}"

          # Verify the test-results-file-path output is populated
          ./test/assert-value-is-not-empty.sh --name "test-results-file-path output" --value "${{ steps.failing-test.outputs.test-results-file-path }}"
          
          # Verify this output is not set because we aren't creating a PR comment or status check
          ./test/assert-value-is-empty.sh --name "test-results-truncated output" --value "${{ steps.failing-test.outputs.test-results-truncated }}"
          ./test/assert-value-is-empty.sh --name "pr-comment-id output" --value "${{ steps.failing-test.outputs.pr-comment-id }}"
          ./test/assert-value-is-empty.sh --name "status-check-ids output" --value "${{ steps.failing-test.outputs.status-check-ids }}"

      - name: 14d - And the contents of ${{ steps.failing-test.outputs.test-results-file-path }} should match the expected markdown
        if: always()
        run: |
          # Comparing the test-results file will ensure that:
          #  - The default timezone is used
          #  - The badge is affected by failures
          #  - The Duration stats are included in the report
          #  - The Counter stats are included in the report
          #  - The failure details are included

          expectedFileName="./test/files/failing-test-ignore/expected-test-results.md"
          actualFileName="${{ steps.failing-test.outputs.test-results-file-path }}"
          ./test/assert-file-contents-match.sh --expectedFileName $expectedFileName --actualFileName $actualFileName

      - name: '--------------------------------------------------------------------------------------------------------------'
        run: echo ""

  test-status-checks:
    runs-on: ubuntu-latest
    env:
      NO_FAILURES_DIR: './test/files/multiple-trx'
      ALLOW_FAILURES_DIR: './test/files/failing-test-allow'
      IGNORE_FAILURES_DIR: './test/files/failing-test-ignore'
      
      NO_FAILURES_MD_FILE: './test/files/multiple-trx/expected-test-results.md'
      ALLOW_FAILURES_MD_FILE: './test/files/failing-test-allow/expected-test-results.md'
      IGNORE_FAILURES_MD_FILE: './test/files/failing-test-ignore/expected-test-results.md'

    steps:
      - name: '-------------------------------------------------------------------------------------------------------------'
        run: echo ""
      - name: '                                                    SETUP                                                    '
        run: echo ""

      - name: Setup - Fail test job if fork
        run: |
          if [ "${{ github.event.pull_request.head.repo.fork }}" == "true" ]; then
            echo "This test job requires the `checks: write` scope on the GITHUB_TOKEN which PRs from forks do not have.  Before this PR can be merged, the tests should be run on an intermediate branch created by repository owners."
            exit 1
          fi

      - name: Setup - Checkout the action
        uses: actions/checkout@v4

      - name: '-------------------------------------------------------------------------------------------------------------'
        run: echo ""
      - name: '                                     TEST 15 - STATUS CHECK - NO FAILURES                                    '
        run: echo ""

      - name: 15a - When process-dotnet-test-results is called with no failures in multiple trx files
        if: always()
        id: no-failures
        uses: ./
        with:
          github-token: '${{ secrets.GITHUB_TOKEN }}'
          base-directory: ${{ env.NO_FAILURES_DIR }}
          create-status-check: true
          create-pr-comment: false

      - name: 15b - Then the action outcome should be success
        if: always()
        run: ./test/assert-values-match.sh --name "step outcome" --expected "success" --actual "${{ steps.no-failures.outcome }}"

      - name: 15c - And the status-check-ids output should be populated
        if: always()
        run: ./test/assert-value-is-not-empty.sh --name "status-check-ids output" --value "${{ steps.no-failures.outputs.status-check-ids }}"

      - name: 15d - And the test-outcome output should be Passed
        if: always()
        run: ./test/assert-values-match.sh --name "test-outcome output" --expected "Passed" --actual "${{ steps.no-failures.outputs.test-outcome }}"

      - name: 15e - And the status check should match the inputs
        if: always()
        uses: actions/github-script@v7
        with:
          script: |
            const fs = require('fs');
            const assertStatusChecksExist = require('./test/assert-status-checks-exist.js');
            const assertStatusCheckMatchesExpectations = require('./test/assert-status-check-matches-expectations.js');

            const checkIds = '${{ steps.no-failures.outputs.status-check-ids }}';
            const actualStatusChecks = await assertStatusChecksExist(github, context, core, checkIds);
            const expectedBody = fs.readFileSync('${{ env.NO_FAILURES_MD_FILE }}', 'utf8');

            const expectedTrx1Values = {
              name: 'status check - dotnet unit tests (multiple.trx1.tests)',
              status: 'completed',
              conclusion: 'success',
              title: 'MULTIPLE.TRX1.TESTS',
              text: expectedBody,
              multipleChecks: true
            };
            const actualTrx1Check = actualStatusChecks.find(check => check.name.includes('trx1'));
            assertStatusCheckMatchesExpectations(core, actualTrx1Check, expectedTrx1Values);

            const expectedTrx2Values = {
              name: 'status check - dotnet unit tests (multiple.trx2.tests)',
              status: 'completed',
              conclusion: 'success',
              title: 'MULTIPLE.TRX2.TESTS',
              text: expectedBody,
              multipleChecks: true
            };
            const actualTrx2Check = actualStatusChecks.find(check => check.name.includes('trx2'));
            assertStatusCheckMatchesExpectations(core, actualTrx2Check, expectedTrx2Values);

      - name: '-------------------------------------------------------------------------------------------------------------'
        run: echo ""
      - name: '                                   TEST 16 - STATUS CHECK - IGNORE FAILURES                                  '
        run: echo ""

      - name: 16a - When process-dotnet-test-results is called with test failures & ignore-test-failures=true
        if: always()
        id: ignore-failures
        uses: ./
        with:
          github-token: '${{ secrets.GITHUB_TOKEN }}'
          base-directory: ${{ env.IGNORE_FAILURES_DIR }}
          create-status-check: true
          ignore-test-failures: true
          create-pr-comment: false

      - name: 16b - Then the action outcome should be success
        if: always()
        run: ./test/assert-values-match.sh --name "step outcome" --expected "success" --actual "${{ steps.ignore-failures.outcome }}"

      - name: 16c - And the status-check-ids output should be populated
        if: always()
        run: ./test/assert-value-is-not-empty.sh --name "status-check-ids output" --value "${{ steps.ignore-failures.outputs.status-check-ids }}"

      - name: 16d - And the test-outcome output should be Failed
        if: always()
        run: ./test/assert-values-match.sh --name "test-outcome output" --expected "Failed" --actual "${{ steps.ignore-failures.outputs.test-outcome }}"

      - name: 16e - And the status check should match the inputs
        if: always()
        uses: actions/github-script@v7
        with:
          script: |
            const fs = require('fs');
            const assertStatusChecksExist = require('./test/assert-status-checks-exist.js');
            const assertStatusCheckMatchesExpectations = require('./test/assert-status-check-matches-expectations.js');

            const checkIds = '${{ steps.ignore-failures.outputs.status-check-ids }}';
            const actualStatusChecks = await assertStatusChecksExist(github, context, core, checkIds);
            const expectedBody = fs.readFileSync('${{ env.IGNORE_FAILURES_MD_FILE }}', 'utf8');

            const expectedValues = {
              name: 'status check - dotnet unit tests (ignore.failures)',
              status: 'completed',
              conclusion: 'neutral',
              title: 'IGNORE.FAILURES',
              text: expectedBody
            };
            const actualCheck = actualStatusChecks.find(check => check.name.includes('ignore'));
            assertStatusCheckMatchesExpectations(core, actualCheck, expectedValues);

      - name: '-------------------------------------------------------------------------------------------------------------'
        run: echo ""
      - name: '                                    TEST 17 - STATUS CHECK - ALLOW FAILURES                                    '
        run: echo ""

      - name: 17a - When process-dotnet-test-results is called with test failures & ignore-test-failures=false
        if: always()
        id: allow-failures
        uses: ./
        with:
          github-token: '${{ secrets.GITHUB_TOKEN }}'
          base-directory: ${{ env.ALLOW_FAILURES_DIR }}
          create-status-check: true
          ignore-test-failures: false
          create-pr-comment: false

      - name: 17b - Then the action outcome should be success
        if: always()
        run: ./test/assert-values-match.sh --name "step outcome" --expected "success" --actual "${{ steps.allow-failures.outcome }}"

      - name: 17c - And the status-check-ids output should be populated
        if: always()
        run: ./test/assert-value-is-not-empty.sh --name "status-check-ids output" --value "${{ steps.allow-failures.outputs.status-check-ids }}"

      - name: 17d - And the test-outcome output should be Failed
        if: always()
        run: ./test/assert-values-match.sh --name "test-outcome output" --expected "Failed" --actual "${{ steps.allow-failures.outputs.test-outcome }}"

      - name: 17e - And the status check should match the inputs
        if: always()
        uses: actions/github-script@v7
        with:
          script: |
            const fs = require('fs');
            const assertStatusChecksExist = require('./test/assert-status-checks-exist.js');
            const assertStatusCheckMatchesExpectations = require('./test/assert-status-check-matches-expectations.js');

            const checkIds = '${{ steps.allow-failures.outputs.status-check-ids }}';
            const actualStatusChecks = await assertStatusChecksExist(github, context, core, checkIds);
            const expectedBody = fs.readFileSync('${{ env.ALLOW_FAILURES_MD_FILE }}', 'utf8');

            const expectedValues = {
              name: 'status check - dotnet unit tests (allow.failures)',
              status: 'completed',
              conclusion: 'failure',
              title: 'ALLOW.FAILURES',
              text: expectedBody
            };
            const actualCheck = actualStatusChecks.find(check => check.name.includes('allow'));
            assertStatusCheckMatchesExpectations(core, actualCheck, expectedValues);

      - name: '-------------------------------------------------------------------------------------------------------------'
        run: echo ""
      - name: '                                                   TEARDOWN                                                  '
        run: echo ""

      - name: Teardown - Modify failing Status Check conclusion
        if: always()
        uses: actions/github-script@v7
        with:
          script: |
            const fs = require('fs');
            const updateFailingStatusCheck = require('./test/update-failing-status-check.js');

            await updateFailingStatusCheck(github, context, core, '${{ steps.allow-failures.outputs.status-check-ids }}');

      - name: '-------------------------------------------------------------------------------------------------------------'
        run: echo ""

  test-pr-comments:
    runs-on: ubuntu-latest
    env:
      EXISTING_COMMENT_ID: ''
      COMMENT_IDENTIFIER: 'existing-comment-${{ github.run_id }}'

      NO_FAILURES_DIR: './test/files/multiple-trx'
      TRUNCATE_DIR: './test/files/truncate'

      NO_FAILURES_MD_FILE: './test/files/multiple-trx/expected-test-results.md'
      TRUNCATE_FULL_MD_FILE: './test/files/truncate/expected-test-results.md'
      TRUNCATE_TRUNCATED_MD_FILE: './test/files/truncate/truncated-results.md'
      

    steps:
      - name: '-------------------------------------------------------------------------------------------------------------'
        run: echo ""
      - name: '                                                    SETUP                                                    '
        run: echo ""

      - name: Setup - Fail test job if fork
        run: |
          if [ "${{ github.event.pull_request.head.repo.fork }}" == "true" ]; then
            echo "This test job requires the `pull_request: write` scope on the GITHUB_TOKEN which PRs from forks do not have.  Before this PR can be merged, the tests should be run on an intermediate branch created by repository owners."
            exit 1
          fi

      - name: Setup - Checkout the action
        uses: actions/checkout@v4

      - name: Setup - Delete pre-existing process-dotnet-test-results PR Comments
        if: always()
        uses: actions/github-script@v7
        with:
          script: |
            const deletePrComments = require('./test/delete-pre-existing-comments.js');
            await deletePrComments(github, context, core);

      - name: Setup - Create a process-dotnet-test-results comment that can be updated
        if: always()
        uses: actions/github-script@v7
        with:
          script: |
            await github.rest.issues.createComment({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: context.issue.number,
              body: '<!-- im-open/process-dotnet-test-results ${{ env.COMMENT_IDENTIFIER }} -->\nThis comment will be replaced soon.'
            })
            .then(response => {
              core.exportVariable('EXISTING_COMMENT_ID', response.data.id);
            })
            .catch(error => {
              core.setFailed(`An error occurred in the setup step while creating a comment: ${error.message}`);
            });
            await new Promise(r => setTimeout(r, 5 * 1000));

      - name: '-------------------------------------------------------------------------------------------------------------'
        run: echo ""
      - name: '                              TEST 18 - PR COMMENT - UPDATE W/ MATCHING PREFIX                               '
        run: echo ""

      - name: 18a - When process-dotnet-test-results is called with updateComment=true and there is a comment with matching prefix
        if: always()
        id: update-with-matching-prefix
        uses: ./
        with:
          github-token: '${{ secrets.GITHUB_TOKEN }}'
          base-directory: ${{ env.NO_FAILURES_DIR }}
          create-status-check: false
          create-pr-comment: true
          update-comment-if-one-exists: true
          comment-identifier: ${{ env.COMMENT_IDENTIFIER }}

      - name: 18b - Then the action outcome should be success
        if: always()
        run: ./test/assert-values-match.sh --name "step outcome" --expected "success" --actual "${{ steps.update-with-matching-prefix.outcome }}"

      - name: 18c - And the pr-comment-id output should match the existing comment id
        if: always()
        run: ./test/assert-values-match.sh --name "pr-comment-id output" --expected "${{ env.EXISTING_COMMENT_ID }}" --actual "${{ steps.update-with-matching-prefix.outputs.pr-comment-id }}"

      - name: 18d - And the test-results-truncated output should be false
        if: always()
        run: ./test/assert-values-match.sh --name "test-results-truncated output" --expected "false" --actual "${{ steps.update-with-matching-prefix.outputs.test-results-truncated }}"

      - name: 18e - And the pr-comment should match the match the expected values
        if: always()
        uses: actions/github-script@v7
        with:
          script: |
            const fs = require('fs');
            const assertCommentExists = require('./test/assert-pr-comment-exists.js');
            const assertCommentMatchesExpectations = require('./test/assert-pr-comment-matches-expectations.js');

            const commentId = '${{ steps.update-with-matching-prefix.outputs.pr-comment-id }}';
            const actualComment = await assertCommentExists(github, context, core, commentId);

            const expectedMarkdown = fs.readFileSync('${{ env.NO_FAILURES_MD_FILE }}', 'utf8');
            const actualTestResults = fs.readFileSync('${{ steps.update-with-matching-prefix.outputs.test-results-file-path }}', 'utf8');

            const expectedComment = {
              prefix: '<!-- im-open/process-dotnet-test-results ${{ env.COMMENT_IDENTIFIER }} -->',
              fullMarkdown: expectedMarkdown,
              action: 'updated',
              truncated: false
            };
            assertCommentMatchesExpectations(core, actualComment, actualTestResults, expectedComment);

      - name: '-------------------------------------------------------------------------------------------------------------'
        run: echo ""
      - name: '                              TEST 19 - PR COMMENT - UPDATE W/O MATCHING PREFIX                              '
        run: echo ""

      - name: 19a - When process-dotnet-test-results is called with updateComment=true but there is no comment with matching prefix
        if: always()
        id: update-without-matching-prefix
        uses: ./
        with:
          github-token: '${{ secrets.GITHUB_TOKEN }}'
          base-directory: ${{ env.NO_FAILURES_DIR }}
          create-status-check: false
          create-pr-comment: true
          update-comment-if-one-exists: true
          comment-identifier: 'different-identifier-${{ github.run_id }}'

      - name: 19b - Then the action outcome should be success
        if: always()
        run: ./test/assert-values-match.sh --name "step outcome" --expected "success" --actual "${{ steps.update-without-matching-prefix.outcome }}"

      - name: 19c - And the pr-comment-id output should be different than the existing comment id
        if: always()
        run: ./test/assert-values-do-not-match.sh --name "pr-comment-id output" --value1 "${{ env.EXISTING_COMMENT_ID }}" --value2 "${{ steps.update-without-matching-prefix.outputs.pr-comment-id }}"

      - name: 19d - And the test-results-truncated output should be false
        if: always()
        run: ./test/assert-values-match.sh --name "test-results-truncated output" --expected "false" --actual "${{ steps.update-without-matching-prefix.outputs.test-results-truncated }}"

      - name: 19e - And the pr-comment should match the expected values
        if: always()
        uses: actions/github-script@v7
        with:
          script: |
            const fs = require('fs');
            const assertCommentExists = require('./test/assert-pr-comment-exists.js');
            const assertCommentMatchesExpectations = require('./test/assert-pr-comment-matches-expectations.js');

            const commentId = '${{ steps.update-without-matching-prefix.outputs.pr-comment-id }}';
            const actualComment = await assertCommentExists(github, context, core, commentId);

            const expectedMarkdown = fs.readFileSync('${{ env.NO_FAILURES_MD_FILE }}', 'utf8');
            const actualTestResults = fs.readFileSync('${{ steps.update-without-matching-prefix.outputs.test-results-file-path }}', 'utf8');

            const expectedComment = {
              prefix: '<!-- im-open/process-dotnet-test-results different-identifier-${{ github.run_id }} -->',
              fullMarkdown: expectedMarkdown,
              action: 'created',
              truncated: false
            };
            assertCommentMatchesExpectations(core, actualComment, actualTestResults, expectedComment);

      - name: '-------------------------------------------------------------------------------------------------------------'
        run: echo ""
      - name: '                                       TEST 20 - PR COMMENT - NO UPDATE                                      '
        run: echo ""

      - name: 20a - When process-dotnet-test-results is called with updateComment=false
        if: always()
        id: matching-prefix-no-update
        uses: ./
        with:
          github-token: '${{ secrets.GITHUB_TOKEN }}'
          base-directory: ${{ env.NO_FAILURES_DIR }}
          create-status-check: false
          create-pr-comment: true
          update-comment-if-one-exists: false

      - name: 20b - Then the action outcome should be success
        if: always()
        run: ./test/assert-values-match.sh --name "step outcome" --expected "success" --actual "${{ steps.matching-prefix-no-update.outcome }}"

      - name: 20c - And the pr-comment-id output should be different than the existing comment id
        if: always()
        run: ./test/assert-values-do-not-match.sh --name "pr-comment-id output" --value1 "${{ env.EXISTING_COMMENT_ID }}" --value2 "${{ steps.matching-prefix-no-update.outputs.pr-comment-id }}"

      - name: 20d - And the test-results-truncated output should be false
        if: always()
        run: ./test/assert-values-match.sh --name "test-results-truncated output" --expected "false" --actual "${{ steps.matching-prefix-no-update.outputs.test-results-truncated }}"

      - name: 20e - And the pr-comment should match the expected values
        if: always()
        uses: actions/github-script@v7
        with:
          script: |
            const fs = require('fs');
            const assertCommentExists = require('./test/assert-pr-comment-exists.js');
            const assertCommentMatchesExpectations = require('./test/assert-pr-comment-matches-expectations.js');

            const commentId = '${{ steps.matching-prefix-no-update.outputs.pr-comment-id }}';
            const actualComment = await assertCommentExists(github, context, core, commentId);

            const expectedMarkdown = fs.readFileSync('${{ env.NO_FAILURES_MD_FILE }}', 'utf8');
            const actualTestResults = fs.readFileSync('${{ steps.matching-prefix-no-update.outputs.test-results-file-path }}', 'utf8');

            const expectedComment = {
              prefix: `<!-- im-open/process-dotnet-test-results test-pr-comments_matching-prefix-no-update -->`,
              fullMarkdown: expectedMarkdown,
              action: 'created',
              truncated: false
            };
            assertCommentMatchesExpectations(core, actualComment, actualTestResults, expectedComment);

      - name: '-------------------------------------------------------------------------------------------------------------'
        run: echo ""
      - name: '                                       TEST 21 - PR COMMENT - TRUNCATE                                       '
        run: echo ""

      - name: 21a - When process-dotnet-test-results is called with a large comment that needs to be truncated
        if: always()
        id: truncate
        uses: ./
        with:
          github-token: '${{ secrets.GITHUB_TOKEN }}'
          base-directory: ${{ env.TRUNCATE_DIR }}
          create-status-check: false
          create-pr-comment: true
          update-comment-if-one-exists: true
          comment-identifier: ${{ env.COMMENT_IDENTIFIER }}

      - name: 21b - Then the action outcome should be success
        if: always()
        run: ./test/assert-values-match.sh --name "step outcome" --expected "success" --actual "${{ steps.truncate.outcome }}"

      - name: 21c - And the pr-comment-id output should match the existing comment id
        if: always()
        run: ./test/assert-values-match.sh --name "pr-comment-id output" --expected "${{ env.EXISTING_COMMENT_ID }}" --actual "${{ steps.truncate.outputs.pr-comment-id }}"

      - name: 21d - And the test-results-truncated output should be true
        if: always()
        run: ./test/assert-values-match.sh --name "test-results-truncated output" --expected "true" --actual "${{ steps.truncate.outputs.test-results-truncated }}"

      - name: 21e - And the pr-comment should match the expected values
        if: always()
        uses: actions/github-script@v7
        with:
          script: |
            const fs = require('fs');
            const assertCommentExists = require('./test/assert-pr-comment-exists.js');
            const assertCommentMatchesExpectations = require('./test/assert-pr-comment-matches-expectations.js');

            const commentId = '${{ steps.truncate.outputs.pr-comment-id }}';
            const actualComment = await assertCommentExists(github, context, core, commentId);

            const expectedMarkdown = fs.readFileSync('${{ env.TRUNCATE_FULL_MD_FILE }}', 'utf8');
            const expectedTruncatedMarkdown = fs.readFileSync('${{ env.TRUNCATE_TRUNCATED_MD_FILE }}', 'utf8');
            const actualTestResults = fs.readFileSync('${{ steps.truncate.outputs.test-results-file-path }}', 'utf8');
            const truncateMessage = 'Test results truncated due to character limit. See full report in output.';

            const expectedComment = {
              prefix: `<!-- im-open/process-dotnet-test-results ${{ env.COMMENT_IDENTIFIER }} -->`,
              fullMarkdown: expectedMarkdown,
              action: 'updated',
              truncated: true,
              truncatedMarkdown: expectedTruncatedMarkdown,
            };
            assertCommentMatchesExpectations(core, actualComment, actualTestResults, expectedComment);

      - name: '-------------------------------------------------------------------------------------------------------------'
        run: echo ""
      - name: '                                                   TEARDOWN                                                  '
        run: echo ""

      - name: Teardown - Delete PR Comments
        if: always()
        uses: actions/github-script@v7
        with:
          script: |
            const fs = require('fs');
            const deletePrComment = require('./test/delete-pr-comment.js');

            await deletePrComment(github, context, core, '${{ env.EXISTING_COMMENT_ID }}');
            await deletePrComment(github, context, core, '${{ steps.matching-prefix-no-update.outputs.pr-comment-id }}');
            await deletePrComment(github, context, core, '${{ steps.update-without-matching-prefix.outputs.pr-comment-id }}');

      - name: '-------------------------------------------------------------------------------------------------------------'
        run: echo ""
