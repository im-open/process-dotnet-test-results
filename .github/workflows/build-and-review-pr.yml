name: Build and Review PR
run-name: 'Build and Review PR #${{ github.event.pull_request.number }}'

on:
  # https://docs.github.com/en/actions/security-guides/automatic-token-authentication#permissions-for-the-github_token
  #
  # This workflow uses the pull_request trigger which prevents write permissions on the
  # GH_TOKEN and secrets access from public forks.  This should remain as a pull_request
  # trigger to minimize the access public forks have in the repository.  The reduced
  # permissions are adequate but do mean that re-compiles and readme changes will have to be
  # made manually by the PR author.  These auto-updates could be done by this workflow
  # for branches but in order to re-trigger a PR build (which is needed for status checks),
  # we would make the commits with a different user and their PAT.  To minimize exposure
  # and complication we will request those changes be manually made by the PR author.
  pull_request:
    types: [opened, synchronize, reopened]
  # paths:
  #   Do not include specific paths here.  We always want this build to run and produce a
  #   status check which are branch protection rules can use.  If this is skipped because of
  #   path filtering, a status check will not be created and we won't be able to merge the PR
  #   without disabling that requirement.  If we have a status check that is always produced,
  #   we can also use that to require all branches be up to date before they are merged.

jobs:
  build-and-review-pr:
    # This reusable workflow will check to see if an action's source code has changed based on
    # whether the PR includes files that match the files-with-code arg or are in one of the
    # dirs-with-code directories.  If there are source code changes, this reusable workflow
    # will then run the action's build (if one was provided) and update the README.md with the
    # the latest version of the action.  If those two steps result in any changes that need to
    # be committed, the workflow will fail because the PR needs some updates.  Instructions for
    # updating the PR will be available in the build log, the workflow summary and as a PR
    # comment if the PR came from a branch (not a fork).
    # This workflow assumes:
    #  - The main README.md is at the root of the repo
    #  - The README contains a contribution guidelines and usage examples section
    uses: im-open/.github/.github/workflows/reusable-build-and-review-pr.yml@v1
    with:
      action-name: ${{ github.repository }}
      default-branch: main
      readme-name: 'README.md'

      # The id of the contribution guidelines section of the README.md
      readme-contribution-id: '#contributing'

      # The id of the usage examples section of the README.md
      readme-examples-id: '#usage-examples'

      # The files that contain source code for the action.  Only files that affect the action's execution
      # should be included like action.yml or package.json.  Do not include files like README.md or .gitignore.
      # Files do not need to be explicitly provided here if they fall under one of the dirs in dirs-with-code.
      # ** This value must match the same files-with-code argument specified in increment-version-on-merge.yml.
      files-with-code: 'action.yml,package.json,package-lock.json'

      # The directories that contain source code for the action.  Only dirs with files that affect the action's
      # execution should be included like src or dist.  Do not include dirs like .github or node_modules.
      # ** This value must match the same dirs-with-code argument specified in increment-version-on-merge.yml.
      dirs-with-code: 'src,dist'

      # The npm script to run to build the action.  This is typically 'npm run build' if the
      # action needs to be compiled.  For composite-run-steps actions this is typically empty.
      build-command: 'npm run build'

  test:
    runs-on: ubuntu-latest

    env:
      DIR_WITH_NO_TRX: './test/files/dir-with-no-trx-files'
      COMPUTER_NAME: 'MY-MACHINE'

    steps:
      #--------------------------------------
      # SETUP
      #--------------------------------------
      - name: Fail test job if fork
        run: |
          if [ "${{ github.event.pull_request.head.repo.fork }}" == "true" ]; then
            echo "This test job requires the `pull_request: write` & `checks: write` scopes on the GITHUB_TOKEN which PRs from forks do not have.  Before this PR can be merged, the tests should be run on an intermediate branch created by repository owners."
            exit 1
          fi

      - name: '-------------------------------------------------------------------------------------------------------'
        run: echo ""

      - name: Setup - Checkout the action
        uses: actions/checkout@v4

      - name: Setup - Create empty directory
        run: mkdir -p ${{ env.DIR_WITH_NO_TRX }}

      #--------------------------------------
      # TEST - MISSING github-token INPUT
      #--------------------------------------
      - name: '-------------------------------------------------------------------------------------------------------'
        run: echo ""

      - name: When process-dotnet-test-results is called with a missing github-token input
        id: missing-github-token
        if: always()
        continue-on-error: true # This is needed because we expect the step to fail but we need it to "pass" in order for the test job to succeed.
        uses: ./
        with:
          github-token: ''

      - name: Then the action outcome should be failure
        if: always()
        run: ./test/assert-values-match.sh --name "step outcome" --expected "failure" --actual "${{ steps.missing-github-token.outcome }}"

      - name: And each of the outputs should be empty
        if: always()
        run: |
          ./test/assert-value-is-empty.sh --name "test-outcome output" --value "${{ steps.missing-github-token.outputs.test-outcome }}"
          ./test/assert-value-is-empty.sh --name "trx-files output" --value "${{ steps.missing-github-token.outputs.trx-files }}"
          ./test/assert-value-is-empty.sh --name "test-results-truncated output" --value "${{ steps.missing-github-token.outputs.test-results-truncated }}"
          ./test/assert-value-is-empty.sh --name "test-results-file-path output" --value "${{ steps.missing-github-token.outputs.test-results-file-path }}"

      #--------------------------------------
      # TEST - RANGE ERROR/NO TRX FILES
      #--------------------------------------
      - name: '-------------------------------------------------------------------------------------------------------'
        run: echo ""

      - name: When process-dotnet-test-results is called with a base-directory that does not contain trx files
        if: always()
        id: range-error
        continue-on-error: true # This is needed because we expect the step to fail but we need it to "pass" in order for the test job to succeed.
        uses: ./
        with:
          github-token: '${{ secrets.GITHUB_TOKEN }}'
          base-directory: ${{ env.DIR_WITH_NO_TRX }}

      - name: Then the action outcome should be success
        if: always()
        run: ./test/assert-values-match.sh --name "step outcome" --expected "success" --actual "${{ steps.range-error.outcome }}"

      - name: And the other outputs should indicate a failure happened
        if: always()
        run: |
          ./test/assert-values-match.sh --name "test-outcome output" --expected "Failed" --actual "${{ steps.range-error.outputs.test-outcome }}"
          ./test/assert-value-is-empty.sh --name "test-results-file-path output" --value "${{ steps.range-error.outputs.test-results-file-path }}"
          ./test/assert-value-is-empty.sh --name "trx-files output" --value "${{ steps.range-error.outputs.trx-files }}"
          ./test/assert-value-is-empty.sh --name "test-results-truncated output" --value "${{ steps.range-error.outputs.test-results-truncated }}"

      #-----------------------------------------
      # TEST - MALFORMED TRX FILES (INVALID XML)
      #-----------------------------------------
      - name: '-------------------------------------------------------------------------------------------------------'
        run: echo ""

      - name: When process-dotnet-test-results is called to process a malformed trx file (invalid xml)
        if: always()
        id: malformed-xml
        continue-on-error: true # This is needed because we expect the step to fail but we need it to "pass" in order for the test job to succeed.
        uses: ./
        with:
          github-token: ${{ secrets.GITHUB_TOKEN }}
          base-directory: './test/files/malformed-xml'

      - name: Then the action outcome should be failure
        if: always()
        run: ./test/assert-values-match.sh --name "step outcome" --expected "failure" --actual "${{ steps.malformed-xml.outcome }}"

      - name: And the other outputs should indicate a failure happened
        if: always()
        run: |
          ./test/assert-values-match.sh --name "test-outcome output" --expected "Failed" --actual "${{ steps.malformed-xml.outputs.test-outcome }}"
          ./test/assert-value-is-empty.sh --name "test-results-file-path output" --value "${{ steps.malformed-xml.outputs.test-results-file-path }}"
          ./test/assert-value-is-empty.sh --name "trx-files output" --value "${{ steps.malformed-xml.outputs.trx-files }}"
          ./test/assert-value-is-empty.sh --name "test-results-truncated output" --value "${{ steps.malformed-xml.outputs.test-results-truncated }}"

      #-----------------------------------------
      # TEST - TRX MISSING TestRun node
      #-----------------------------------------
      - name: '-------------------------------------------------------------------------------------------------------'
        run: echo ""

      - name: When process-dotnet-test-results is called with a trx file that is missing the TestRun node
        if: always()
        id: missing-testrun
        continue-on-error: true # This is needed because we expect the step to fail but we need it to "pass" in order for the test job to succeed.
        uses: ./
        with:
          github-token: '${{ secrets.GITHUB_TOKEN }}'
          base-directory: './test/files/missing-testrun'

      - name: Then the action outcome should be failure
        if: always()
        run: ./test/assert-values-match.sh --name "step outcome" --expected "failure" --actual "${{ steps.missing-testrun.outcome }}"

      - name: And the other outputs should indicate a failure happened
        if: always()
        run: |
          ./test/assert-values-match.sh --name "test-outcome output" --expected "Failed" --actual "${{ steps.missing-testrun.outputs.test-outcome }}"
          ./test/assert-value-is-empty.sh --name "test-results-file-path output" --value "${{ steps.missing-testrun.outputs.test-results-file-path }}"
          ./test/assert-value-is-empty.sh --name "trx-files output" --value "${{ steps.missing-testrun.outputs.trx-files }}"
          ./test/assert-value-is-empty.sh --name "test-results-truncated output" --value "${{ steps.missing-testrun.outputs.test-results-truncated }}"

      #-----------------------------------------
      # TEST - TRX MISSING TestRun.ResultSummary node
      #-----------------------------------------
      - name: '-------------------------------------------------------------------------------------------------------'
        run: echo ""

      - name: When process-dotnet-test-results is called with a trx file that is missing the TestRun.ResultSummary node
        if: always()
        id: missing-resultsummary
        continue-on-error: true # This is needed because we expect the step to fail but we need it to "pass" in order for the test job to succeed.
        uses: ./
        with:
          github-token: '${{ secrets.GITHUB_TOKEN }}'
          base-directory: './test/files/missing-resultsummary'

      - name: Then the action outcome should be failure
        if: always()
        run: ./test/assert-values-match.sh --name "step outcome" --expected "failure" --actual "${{ steps.missing-resultsummary.outcome }}"

      - name: And the other outputs should indicate a failure happened
        if: always()
        run: |
          ./test/assert-values-match.sh --name "test-outcome output" --expected "Failed" --actual "${{ steps.missing-resultsummary.outputs.test-outcome }}"
          ./test/assert-value-is-empty.sh --name "test-results-file-path output" --value "${{ steps.missing-resultsummary.outputs.test-results-file-path }}"
          ./test/assert-value-is-empty.sh --name "trx-files output" --value "${{ steps.missing-resultsummary.outputs.trx-files }}"
          ./test/assert-value-is-empty.sh --name "test-results-truncated output" --value "${{ steps.missing-resultsummary.outputs.test-results-truncated }}"

      #-------------------------------------------------------
      # TEST - TRX MISSING TestRun.ResultSummary.Counters node
      #-------------------------------------------------------
      - name: '-------------------------------------------------------------------------------------------------------'
        run: echo ""

      - name: When process-dotnet-test-results is called with a trx file that is missing the TestRun.ResultSummary.Counters node
        if: always()
        id: missing-counters
        continue-on-error: true # This is needed because we expect the step to fail but we need it to "pass" in order for the test job to succeed.
        uses: ./
        with:
          github-token: '${{ secrets.GITHUB_TOKEN }}'
          base-directory: './test/files/missing-counters'

      - name: Then the action outcome should be failure
        if: always()
        run: ./test/assert-values-match.sh --name "step outcome" --expected "failure" --actual "${{ steps.missing-counters.outcome }}"

      - name: And the other outputs should indicate a failure happened
        if: always()
        run: |
          ./test/assert-values-match.sh --name "test-outcome output" --expected "Failed" --actual "${{ steps.missing-counters.outputs.test-outcome }}"
          ./test/assert-value-is-empty.sh --name "test-results-file-path output" --value "${{ steps.missing-counters.outputs.test-results-file-path }}"
          ./test/assert-value-is-empty.sh --name "trx-files output" --value "${{ steps.missing-counters.outputs.trx-files }}"
          ./test/assert-value-is-empty.sh --name "test-results-truncated output" --value "${{ steps.missing-counters.outputs.test-results-truncated }}"

      #-------------------------------------------------------
      # TEST - TRX MISSING TestRun.ResultSummary.RunInfos node
      #-------------------------------------------------------
      - name: '-------------------------------------------------------------------------------------------------------'
        run: echo ""

      - name: When process-dotnet-test-results is called with a trx file that is missing the TestRun.ResultSummary.RunInfos node
        if: always()
        id: missing-runinfos
        continue-on-error: true # This is needed because we expect the step to fail but we need it to "pass" in order for the test job to succeed.
        uses: ./
        with:
          github-token: '${{ secrets.GITHUB_TOKEN }}'
          base-directory: './test/files/missing-runinfos'

      - name: Then the action outcome should be failure
        if: always()
        run: ./test/assert-values-match.sh --name "step outcome" --expected "failure" --actual "${{ steps.missing-runinfos.outcome }}"

      - name: And the other outputs should indicate a failure happened
        if: always()
        run: |
          ./test/assert-values-match.sh --name "test-outcome output" --expected "Failed" --actual "${{ steps.missing-runinfos.outputs.test-outcome }}"
          ./test/assert-value-is-empty.sh --name "test-results-file-path output" --value "${{ steps.missing-runinfos.outputs.test-results-file-path }}"
          ./test/assert-value-is-empty.sh --name "trx-files output" --value "${{ steps.missing-runinfos.outputs.trx-files }}"
          ./test/assert-value-is-empty.sh --name "test-results-truncated output" --value "${{ steps.missing-runinfos.outputs.test-results-truncated }}"

      #---------------------------------------------------------------
      # TEST - TRX MISSING TestRun.ResultSummary.RunInfos.RunInfo node
      #---------------------------------------------------------------
      - name: '-------------------------------------------------------------------------------------------------------'
        run: echo ""

      - name: When process-dotnet-test-results is called with a trx file that is missing the TestRun.ResultSummary.RunInfos.RunInfo node
        if: always()
        id: missing-runinfo
        continue-on-error: true # This is needed because we expect the step to fail but we need it to "pass" in order for the test job to succeed.
        uses: ./
        with:
          github-token: '${{ secrets.GITHUB_TOKEN }}'
          base-directory: './test/files/missing-runinfo'

      - name: Then the action outcome should be failure
        if: always()
        run: ./test/assert-values-match.sh --name "step outcome" --expected "failure" --actual "${{ steps.missing-runinfo.outcome }}"

      - name: And the other outputs should indicate a failure happened
        if: always()
        run: |
          ./test/assert-values-match.sh --name "test-outcome output" --expected "Failed" --actual "${{ steps.missing-runinfo.outputs.test-outcome }}"
          ./test/assert-value-is-empty.sh --name "test-results-file-path output" --value "${{ steps.missing-runinfo.outputs.test-results-file-path }}"
          ./test/assert-value-is-empty.sh --name "trx-files output" --value "${{ steps.missing-runinfo.outputs.trx-files }}"
          ./test/assert-value-is-empty.sh --name "test-results-truncated output" --value "${{ steps.missing-runinfo.outputs.test-results-truncated }}"

      #-----------------------------------------------------------------------------------------------------------
      # TEST - NO TESTS BUT CREATE RESULTS FILE (empty TestRun.Results && TestRun.TestDefinitions)
      # Comparing the test-results.md file will ensure that:
      #  - The correct timezone is used
      #  - The computer name is used for report title when there are no tests
      #  - The test icon is correct when the outcome doesn't match expected scenarios (passed/failed/notexecuted)
      #  - The Duration stats are included in the report
      #  - The Counter stats are included in the report
      #-----------------------------------------------------------------------------------------------------------
      
      - name: '-------------------------------------------------------------------------------------------------------'
        run: echo ""

      - name: When process-dotnet-test-results is called with a file that does not contain test results or test definitions
        if: always()
        id: no-tests
        uses: ./
        with:
          github-token: '${{ secrets.GITHUB_TOKEN }}'
          base-directory: './test/files/no-tests'
          create-results-file: true # Keep this so we have an "actual" output to compare against
          create-status-check: false
          create-pr-comment: false
          timezone: 'America/Denver'

      - name: Then the action outcome should be success
        if: always()
        run: ./test/assert-values-match.sh --name "step outcome" --expected "success" --actual "${{ steps.no-tests.outcome }}"

      - name: And the trx-files output should be contain the no-tests.trx file
        if: always()
        run: ./test/assert-values-match.sh --name "trx-files output" --expected "[./test/files/no-tests/no-tests.trx]" --actual "${{ steps.no-tests.outputs.trx-files }}"

      - name: And the test-outcome output should be Passed because there are no failing tests
        if: always()
        run: ./test/assert-values-match.sh --name "test-outcome output" --expected "Passed" --actual "${{ steps.no-tests.outputs.test-outcome }}"

      - name: And the test-results-file-path output and env var should be populated with 'test-results.md'
        if: always()
        run: |
          ./test/assert-values-match.sh --name "test-results-file-path output" --expected "${{ github.workspace }}/test-results.md" --actual "${{ steps.no-tests.outputs.test-results-file-path }}"
          ./test/assert-values-match.sh --name "test-results-file-path envVar" --expected "${{ github.workspace }}/test-results.md" --actual "${{ env.TEST_RESULTS_FILE_PATH }}"

      - name: And the test-results-truncated output should be empty because a PR comment is not being created
        if: always()
        run: ./test/assert-value-is-empty.sh --name "test-results-truncated output" --value "${{ steps.no-tests.outputs.test-results-truncated }}"

      - name: And the contents of test-results.md file should match the contents of expected-test-results.md file
        if: always()
        run: |
          TARGET_FILE="./test-results.md"

          if [ -f "$TARGET_FILE" ]
          then
            echo "$TARGET_FILE exists which is expected."
            actualContent=$(cat $TARGET_FILE)
          else
            echo "$TARGET_FILE does not exist which is not expected"
            exit 1
          fi
          expectedContent=$(cat ./test/files/no-tests/expected-test-results.md)

          ./test/assert-values-match.sh --name "test-results.md content" --expected "$expectedContent" --actual "$actualContent"

      #-------------------------------------------------------------------------------------------------------------------------------
      # TEST - NO UNIT TEST RESULTS BUT CREATE RESULTS FILE(empty TestRun.Results.UnitTestResult && TestRun.TestDefinitions.UnitTest)
      # Comparing the test-results.md file will ensure that:
      #  - The default timezone is used
      #  - 'Not Found' is used for report title when there are no tests and no _computerName attr present
      #  - The test icon is correct when the outcome doesn't match expected scenarios (passed/failed/notexecuted)
      #  - The Duration stats are included in the report
      #  - The Counter stats are included in the report
      #-------------------------------------------------------------------------------------------------------------------------------
      - name: '-------------------------------------------------------------------------------------------------------'
        run: |
          echo ""
          echo "TEST_RESULTS_FILE_PATH=" >> "$GITHUB_ENV"
          rm -f ./test-results.md

      - name: When process-dotnet-test-results is called with a file that does not contain unit test results or unit test definitions
        if: always()
        id: no-unit-tests
        uses: ./
        with:
          github-token: '${{ secrets.GITHUB_TOKEN }}'
          base-directory: './test/files/no-unit-tests'
          create-results-file: true # Keep this so we have an "actual" output to compare against
          create-status-check: false
          create-pr-comment: false

      - name: Then the action outcome should be success
        if: always()
        run: ./test/assert-values-match.sh --name "step outcome" --expected "success" --actual "${{ steps.no-unit-tests.outcome }}"

      - name: And the trx-files output should be contain the no-unit-tests.trx file
        if: always()
        run: ./test/assert-values-match.sh --name "trx-files output" --expected "[./test/files/no-unit-tests/no-unit-tests.trx]" --actual "${{ steps.no-unit-tests.outputs.trx-files }}"

      - name: And the test-outcome output should be Passed because there are no failing tests
        if: always()
        run: ./test/assert-values-match.sh --name "test-outcome output" --expected "Passed" --actual "${{ steps.no-unit-tests.outputs.test-outcome }}"

      - name: And the test-results-file-path output and env var should be populated with 'test-results.md'
        if: always()
        run: |
          ./test/assert-values-match.sh --name "test-results-file-path output" --expected "${{ github.workspace }}/test-results.md" --actual "${{ steps.no-unit-tests.outputs.test-results-file-path }}"
          ./test/assert-values-match.sh --name "test-results-file-path envVar" --expected "${{ github.workspace }}/test-results.md" --actual "${{ env.TEST_RESULTS_FILE_PATH }}"

      - name: And the test-results-truncated output should be empty because a PR comment is not being created
        if: always()
        run: ./test/assert-value-is-empty.sh --name "test-results-truncated output" --value "${{ steps.no-unit-tests.outputs.test-results-truncated }}"

      - name: And the contents of test-results.md file should match the contents of expected-test-results.md file
        if: always()
        run: |
          TARGET_FILE="./test-results.md"

          if [ -f "$TARGET_FILE" ]
          then
            echo "$TARGET_FILE exists which is expected."
            actualContent=$(cat $TARGET_FILE)
          else
            echo "$TARGET_FILE does not exist which is not expected"
            exit 1
          fi
          expectedContent=$(cat ./test/files/no-unit-tests/expected-test-results.md)

          ./test/assert-values-match.sh --name "test-results.md content" --expected "$expectedContent" --actual "$actualContent"


      #-------------------------------------------------------------------------------------------------------------------------------
      # TEST - SINGLE UNIT TEST & DEFAULT REPORT TITLE (single result in TestRun.Results.UnitTestResult)
      # Comparing the test-results.md file will ensure that:
      #  - The default timezone is used
      #  - The dll name is used for report title when a report title filter is not specified
      #  - The test icon is matches the passed test outcome
      #  - The Duration stats are included in the report
      #  - The Counter stats are included in the report
      #-------------------------------------------------------------------------------------------------------------------------------
      - name: '-------------------------------------------------------------------------------------------------------'
        run: |
          echo ""
          echo "TEST_RESULTS_FILE_PATH=" >> "$GITHUB_ENV"
          rm -f ./test-results.md

      - name: When process-dotnet-test-results is called with a file that reports a single test
        if: always()
        id: single-test
        uses: ./
        with:
          github-token: '${{ secrets.GITHUB_TOKEN }}'
          base-directory: './test/files/single-test'
          create-results-file: true # Keep this so we have an "actual" output to compare against
          create-status-check: false
          create-pr-comment: false

      - name: Then the action outcome should be success
        if: always()
        run: ./test/assert-values-match.sh --name "step outcome" --expected "success" --actual "${{ steps.single-test.outcome }}"

      - name: And the outputs should indicate a success happened
        if: always()
        run : |
          # Verify the trx-files list matches what we expect
          ./test/assert-values-match.sh --name "trx-files output" --expected "[./test/files/single-test/single-test.trx]" --actual "${{ steps.single-test.outputs.trx-files }}"
          
          # Verify the test-outcome is passed
          ./test/assert-values-match.sh --name "test-outcome output" --expected "Passed" --actual "${{ steps.single-test.outputs.test-outcome }}"

          # Verify the test-results-file-path output and env var should be populated with 'test-results.md'
          ./test/assert-values-match.sh --name "test-results-file-path output" --expected "${{ github.workspace }}/test-results.md" --actual "${{ steps.single-test.outputs.test-results-file-path }}"
          ./test/assert-values-match.sh --name "test-results-file-path envVar" --expected "${{ github.workspace }}/test-results.md" --actual "${{ env.TEST_RESULTS_FILE_PATH }}"

          # Verify this output is not set because we aren't creating a PR comment
          ./test/assert-value-is-empty.sh --name "test-results-truncated output" --value "${{ steps.single-test.outputs.test-results-truncated }}"

      - name: And the contents of test-results.md file should match the contents of expected-test-results.md file
        if: always()
        run: |
          TARGET_FILE="./test-results.md"

          if [ -f "$TARGET_FILE" ]
          then
            echo "$TARGET_FILE exists which is expected."
            actualContent=$(cat $TARGET_FILE)
          else
            echo "$TARGET_FILE does not exist which is not expected"
            exit 1
          fi
          expectedContent=$(cat ./test/files/single-test/expected-test-results.md)

          ./test/assert-values-match.sh --name "test-results.md content" --expected "$expectedContent" --actual "$actualContent"

      

      # Conditions:

      
      # using report title filter
      # has a failing test && create-status-check=true && ignoreTestFailures=false  (test-outcome output = Failed, status check=failure)
      # has a failing test && create-status-check=true && ignoreTestFailures=true  (test-outcome output = Failed, status check=neutral)
      # no failing tests && create-status-check=true (test-outcome output = Passed, status check=success)
      # creating status check (one per trx)
      # creating pr comment with normal message && update-comment-if-one-exists=true (test-results-truncated output = false)
      # creating pr comment with normal message && update-comment-if-one-exists=false (test-results-truncated output = false)
      # creating pr comment with truncated message && new comment-identifier (test-results-truncated output = true)

      # creating results file - Use this to determine the actual output

      #---------------------------------------------------------------------------------------------
      #-----------------------------------------
      # TEST -
      #-----------------------------------------
      # - name: '-------------------------------------------------------------------------------------------------------'
      #   run: echo ""

      # - name: When process-dotnet-test-results is called with
      #   if: always()
      #   id: change-me
      #   uses: ./
      #   with:
      #     github-token: '${{ secrets.GITHUB_TOKEN }}'
      #     base-directory: './test/files/'
      #     ignore-test-failures: false
      #     create-status-check: true
      #     create-pr-comment: true
      #     create-results-file: true
      #     update-comment-if-one-exists: true
      #     timezone: 'America/Denver'
      #     comment-identifier: 'dotnet-test-results'
      #     report-title-filter: '?'

      #--------------------------------------
      # TEARDOWN -
      #--------------------------------------
      - name: '-------------------------------------------------------------------------------------------------------'
        run: echo ""
