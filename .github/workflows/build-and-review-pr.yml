name: Build and Review PR
run-name: 'Build and Review PR #${{ github.event.pull_request.number }}'

on:
  # https://docs.github.com/en/actions/security-guides/automatic-token-authentication#permissions-for-the-github_token
  #
  # This workflow uses the pull_request trigger which prevents write permissions on the
  # GH_TOKEN and secrets access from public forks.  This should remain as a pull_request
  # trigger to minimize the access public forks have in the repository.  The reduced
  # permissions are adequate but do mean that re-compiles and readme changes will have to be
  # made manually by the PR author.  These auto-updates could be done by this workflow
  # for branches but in order to re-trigger a PR build (which is needed for status checks),
  # we would make the commits with a different user and their PAT.  To minimize exposure
  # and complication we will request those changes be manually made by the PR author.
  pull_request:
    types: [opened, synchronize, reopened]
  # paths:
  #   Do not include specific paths here.  We always want this build to run and produce a
  #   status check which are branch protection rules can use.  If this is skipped because of
  #   path filtering, a status check will not be created and we won't be able to merge the PR
  #   without disabling that requirement.  If we have a status check that is always produced,
  #   we can also use that to require all branches be up to date before they are merged.

jobs:
  build-and-review-pr:
    # This reusable workflow will check to see if an action's source code has changed based on
    # whether the PR includes files that match the files-with-code arg or are in one of the
    # dirs-with-code directories.  If there are source code changes, this reusable workflow
    # will then run the action's build (if one was provided) and update the README.md with the
    # the latest version of the action.  If those two steps result in any changes that need to
    # be committed, the workflow will fail because the PR needs some updates.  Instructions for
    # updating the PR will be available in the build log, the workflow summary and as a PR
    # comment if the PR came from a branch (not a fork).
    # This workflow assumes:
    #  - The main README.md is at the root of the repo
    #  - The README contains a contribution guidelines and usage examples section
    uses: im-open/.github/.github/workflows/reusable-build-and-review-pr.yml@v1
    with:
      action-name: ${{ github.repository }}
      default-branch: main
      readme-name: 'README.md'

      # The id of the contribution guidelines section of the README.md
      readme-contribution-id: '#contributing'

      # The id of the usage examples section of the README.md
      readme-examples-id: '#usage-examples'

      # The files that contain source code for the action.  Only files that affect the action's execution
      # should be included like action.yml or package.json.  Do not include files like README.md or .gitignore.
      # Files do not need to be explicitly provided here if they fall under one of the dirs in dirs-with-code.
      # ** This value must match the same files-with-code argument specified in increment-version-on-merge.yml.
      files-with-code: 'action.yml,package.json,package-lock.json'

      # The directories that contain source code for the action.  Only dirs with files that affect the action's
      # execution should be included like src or dist.  Do not include dirs like .github or node_modules.
      # ** This value must match the same dirs-with-code argument specified in increment-version-on-merge.yml.
      dirs-with-code: 'src,dist'

      # The npm script to run to build the action.  This is typically 'npm run build' if the
      # action needs to be compiled.  For composite-run-steps actions this is typically empty.
      build-command: 'npm run build'

  test-unit:
    runs-on: ubuntu-latest
    if: 1 == 2
    env:
      DIR_WITH_NO_TRX: './test/files/dir-with-no-trx-files'

    steps:
      - name: '-------------------------------------------------------------------------------------------------------------'
        run: echo ""
      - name: '                                                    SETUP                                                    '
        run: echo ""

      - name: Setup - Checkout the action
        uses: actions/checkout@v4

      - name: Setup - Create empty directory
        run: mkdir -p ${{ env.DIR_WITH_NO_TRX }}

      - name: '-------------------------------------------------------------------------------------------------------------'
        run: echo ""
      - name: '                                           TEST 1 - MISSING TOKEN                                            '
        run: echo ""

      - name: 1 - When process-dotnet-test-results is called with a missing github-token input
        id: missing-github-token
        if: always()
        continue-on-error: true # This is needed because we expect the step to fail but we need it to "pass" in order for the test job to succeed.
        uses: ./
        with:
          github-token: ''

      - name: 1 - Then the action outcome should be failure
        if: always()
        run: ./test/assert-values-match.sh --name "step outcome" --expected "failure" --actual "${{ steps.missing-github-token.outcome }}"

      - name: 1 - And each of the outputs should be empty
        if: always()
        run: |
          ./test/assert-value-is-empty.sh --name "test-outcome output" --value "${{ steps.missing-github-token.outputs.test-outcome }}"
          ./test/assert-value-is-empty.sh --name "trx-files output" --value "${{ steps.missing-github-token.outputs.trx-files }}"
          ./test/assert-value-is-empty.sh --name "test-results-truncated output" --value "${{ steps.missing-github-token.outputs.test-results-truncated }}"
          ./test/assert-value-is-empty.sh --name "test-results-file-path output" --value "${{ steps.missing-github-token.outputs.test-results-file-path }}"
          ./test/assert-value-is-empty.sh --name "status-check-id output" --value "${{ steps.missing-github-token.outputs.status-check-ids }}"
          ./test/assert-value-is-empty.sh --name "pr-comment-id output" --value "${{ steps.missing-github-token.outputs.pr-comment-id }}"

      - name: '-------------------------------------------------------------------------------------------------------------'
        run: echo ""
      - name: '                                            TEST 2 - NO TRX FILES                                            '
        run: echo ""

      - name: 2 - When process-dotnet-test-results is called with a base-directory that does not contain trx files
        if: always()
        id: range-error
        continue-on-error: true # This is needed because we expect the step to fail but we need it to "pass" in order for the test job to succeed.
        uses: ./
        with:
          github-token: '${{ secrets.GITHUB_TOKEN }}'
          base-directory: ${{ env.DIR_WITH_NO_TRX }}

      - name: 2 - Then the action outcome should be success
        if: always()
        run: ./test/assert-values-match.sh --name "step outcome" --expected "success" --actual "${{ steps.range-error.outcome }}"

      - name: 2 - And the other outputs should indicate a failure happened
        if: always()
        run: |
          ./test/assert-values-match.sh --name "test-outcome output" --expected "Failed" --actual "${{ steps.range-error.outputs.test-outcome }}"
          ./test/assert-value-is-empty.sh --name "test-results-file-path output" --value "${{ steps.range-error.outputs.test-results-file-path }}"
          ./test/assert-value-is-empty.sh --name "trx-files output" --value "${{ steps.range-error.outputs.trx-files }}"
          ./test/assert-value-is-empty.sh --name "test-results-truncated output" --value "${{ steps.range-error.outputs.test-results-truncated }}"
          ./test/assert-value-is-empty.sh --name "status-check-id output" --value "${{ steps.range-error.outputs.status-check-ids }}"
          ./test/assert-value-is-empty.sh --name "pr-comment-id output" --value "${{ steps.range-error.outputs.pr-comment-id }}"

      - name: '-------------------------------------------------------------------------------------------------------------'
        run: echo ""
      - name: '                                           TEST 3 - MALFORMED TRX                                            '
        run: echo ""

      - name: 3 - When process-dotnet-test-results is called to process a malformed trx file (invalid xml)
        if: always()
        id: malformed-xml
        continue-on-error: true # This is needed because we expect the step to fail but we need it to "pass" in order for the test job to succeed.
        uses: ./
        with:
          github-token: ${{ secrets.GITHUB_TOKEN }}
          base-directory: './test/files/malformed-xml'

      - name: 3 - Then the action outcome should be failure
        if: always()
        run: ./test/assert-values-match.sh --name "step outcome" --expected "failure" --actual "${{ steps.malformed-xml.outcome }}"

      - name: 3 - And the other outputs should indicate a failure happened
        if: always()
        run: |
          ./test/assert-values-match.sh --name "test-outcome output" --expected "Failed" --actual "${{ steps.malformed-xml.outputs.test-outcome }}"
          ./test/assert-value-is-empty.sh --name "test-results-file-path output" --value "${{ steps.malformed-xml.outputs.test-results-file-path }}"
          ./test/assert-value-is-empty.sh --name "trx-files output" --value "${{ steps.malformed-xml.outputs.trx-files }}"
          ./test/assert-value-is-empty.sh --name "test-results-truncated output" --value "${{ steps.malformed-xml.outputs.test-results-truncated }}"
          ./test/assert-value-is-empty.sh --name "status-check-id output" --value "${{ steps.malformed-xml.outputs.status-check-ids }}"
          ./test/assert-value-is-empty.sh --name "pr-comment-id output" --value "${{ steps.malformed-xml.outputs.pr-comment-id }}"

      - name: '-------------------------------------------------------------------------------------------------------------'
        run: echo ""
      - name: '                                          TEST 4 - MISSING TestRun                                           '
        run: echo ""

      - name: 4 - When process-dotnet-test-results is called with a trx file that is missing the TestRun node
        if: always()
        id: missing-testrun
        continue-on-error: true # This is needed because we expect the step to fail but we need it to "pass" in order for the test job to succeed.
        uses: ./
        with:
          github-token: '${{ secrets.GITHUB_TOKEN }}'
          base-directory: './test/files/missing-testrun'

      - name: 4 - Then the action outcome should be failure
        if: always()
        run: ./test/assert-values-match.sh --name "step outcome" --expected "failure" --actual "${{ steps.missing-testrun.outcome }}"

      - name: 4 - And the other outputs should indicate a failure happened
        if: always()
        run: |
          ./test/assert-values-match.sh --name "test-outcome output" --expected "Failed" --actual "${{ steps.missing-testrun.outputs.test-outcome }}"
          ./test/assert-value-is-empty.sh --name "test-results-file-path output" --value "${{ steps.missing-testrun.outputs.test-results-file-path }}"
          ./test/assert-value-is-empty.sh --name "trx-files output" --value "${{ steps.missing-testrun.outputs.trx-files }}"
          ./test/assert-value-is-empty.sh --name "test-results-truncated output" --value "${{ steps.missing-testrun.outputs.test-results-truncated }}"
          ./test/assert-value-is-empty.sh --name "status-check-id output" --value "${{ steps.missing-testrun.outputs.status-check-ids }}"
          ./test/assert-value-is-empty.sh --name "pr-comment-id output" --value "${{ steps.missing-testrun.outputs.pr-comment-id }}"

      - name: '-------------------------------------------------------------------------------------------------------------'
        run: echo ""
      - name: '                                    TEST 5 - MISSING TestRun.ResultSummary                                   '
        run: echo ""

      - name: 5 - When process-dotnet-test-results is called with a trx file that is missing the TestRun.ResultSummary node
        if: always()
        id: missing-resultsummary
        continue-on-error: true # This is needed because we expect the step to fail but we need it to "pass" in order for the test job to succeed.
        uses: ./
        with:
          github-token: '${{ secrets.GITHUB_TOKEN }}'
          base-directory: './test/files/missing-resultsummary'

      - name: 5 - Then the action outcome should be failure
        if: always()
        run: ./test/assert-values-match.sh --name "step outcome" --expected "failure" --actual "${{ steps.missing-resultsummary.outcome }}"

      - name: 5 - And the other outputs should indicate a failure happened
        if: always()
        run: |
          ./test/assert-values-match.sh --name "test-outcome output" --expected "Failed" --actual "${{ steps.missing-resultsummary.outputs.test-outcome }}"
          ./test/assert-value-is-empty.sh --name "test-results-file-path output" --value "${{ steps.missing-resultsummary.outputs.test-results-file-path }}"
          ./test/assert-value-is-empty.sh --name "trx-files output" --value "${{ steps.missing-resultsummary.outputs.trx-files }}"
          ./test/assert-value-is-empty.sh --name "test-results-truncated output" --value "${{ steps.missing-resultsummary.outputs.test-results-truncated }}"
          ./test/assert-value-is-empty.sh --name "status-check-id output" --value "${{ steps.missing-resultsummary.outputs.status-check-ids }}"
          ./test/assert-value-is-empty.sh --name "pr-comment-id output" --value "${{ steps.missing-resultsummary.outputs.pr-comment-id }}"

      - name: '-------------------------------------------------------------------------------------------------------------'
        run: echo ""
      - name: '                               TEST 6 - MISSING TestRun.ResultSummary.Counters                               '
        run: echo ""

      - name: 6 - When process-dotnet-test-results is called with a trx file that is missing the TestRun.ResultSummary.Counters node
        if: always()
        id: missing-counters
        continue-on-error: true # This is needed because we expect the step to fail but we need it to "pass" in order for the test job to succeed.
        uses: ./
        with:
          github-token: '${{ secrets.GITHUB_TOKEN }}'
          base-directory: './test/files/missing-counters'

      - name: 6 - Then the action outcome should be failure
        if: always()
        run: ./test/assert-values-match.sh --name "step outcome" --expected "failure" --actual "${{ steps.missing-counters.outcome }}"

      - name: 6 - And the other outputs should indicate a failure happened
        if: always()
        run: |
          ./test/assert-values-match.sh --name "test-outcome output" --expected "Failed" --actual "${{ steps.missing-counters.outputs.test-outcome }}"
          ./test/assert-value-is-empty.sh --name "test-results-file-path output" --value "${{ steps.missing-counters.outputs.test-results-file-path }}"
          ./test/assert-value-is-empty.sh --name "trx-files output" --value "${{ steps.missing-counters.outputs.trx-files }}"
          ./test/assert-value-is-empty.sh --name "test-results-truncated output" --value "${{ steps.missing-counters.outputs.test-results-truncated }}"
          ./test/assert-value-is-empty.sh --name "status-check-id output" --value "${{ steps.missing-counters.outputs.status-check-ids }}"
          ./test/assert-value-is-empty.sh --name "pr-comment-id output" --value "${{ steps.missing-counters.outputs.pr-comment-id }}"

      - name: '-------------------------------------------------------------------------------------------------------------'
        run: echo ""
      - name: '                               TEST 7 - MISSING TestRun.ResultSummary.RunInfos                               '
        run: echo ""

      - name: 7 - When process-dotnet-test-results is called with a trx file that is missing the TestRun.ResultSummary.RunInfos node
        if: always()
        id: missing-runinfos
        continue-on-error: true # This is needed because we expect the step to fail but we need it to "pass" in order for the test job to succeed.
        uses: ./
        with:
          github-token: '${{ secrets.GITHUB_TOKEN }}'
          base-directory: './test/files/missing-runinfos'

      - name: 7 - Then the action outcome should be failure
        if: always()
        run: ./test/assert-values-match.sh --name "step outcome" --expected "failure" --actual "${{ steps.missing-runinfos.outcome }}"

      - name: 7 - And the other outputs should indicate a failure happened
        if: always()
        run: |
          ./test/assert-values-match.sh --name "test-outcome output" --expected "Failed" --actual "${{ steps.missing-runinfos.outputs.test-outcome }}"
          ./test/assert-value-is-empty.sh --name "test-results-file-path output" --value "${{ steps.missing-runinfos.outputs.test-results-file-path }}"
          ./test/assert-value-is-empty.sh --name "trx-files output" --value "${{ steps.missing-runinfos.outputs.trx-files }}"
          ./test/assert-value-is-empty.sh --name "test-results-truncated output" --value "${{ steps.missing-runinfos.outputs.test-results-truncated }}"
          ./test/assert-value-is-empty.sh --name "status-check-id output" --value "${{ steps.missing-runinfos.outputs.status-check-ids }}"
          ./test/assert-value-is-empty.sh --name "pr-comment-id output" --value "${{ steps.missing-runinfos.outputs.pr-comment-id }}"

      - name: '-------------------------------------------------------------------------------------------------------------'
        run: echo ""
      - name: '                           TEST 8 - MISSING TestRun.ResultSummary.RunInfos.RunInfo                           '
        run: echo ""

      - name: 8 - When process-dotnet-test-results is called with a trx file that is missing the TestRun.ResultSummary.RunInfos.RunInfo node
        if: always()
        id: missing-runinfo
        continue-on-error: true # This is needed because we expect the step to fail but we need it to "pass" in order for the test job to succeed.
        uses: ./
        with:
          github-token: '${{ secrets.GITHUB_TOKEN }}'
          base-directory: './test/files/missing-runinfo'

      - name: 8 - Then the action outcome should be failure
        if: always()
        run: ./test/assert-values-match.sh --name "step outcome" --expected "failure" --actual "${{ steps.missing-runinfo.outcome }}"

      - name: 8 - And the other outputs should indicate a failure happened
        if: always()
        run: |
          ./test/assert-values-match.sh --name "test-outcome output" --expected "Failed" --actual "${{ steps.missing-runinfo.outputs.test-outcome }}"
          ./test/assert-value-is-empty.sh --name "test-results-file-path output" --value "${{ steps.missing-runinfo.outputs.test-results-file-path }}"
          ./test/assert-value-is-empty.sh --name "trx-files output" --value "${{ steps.missing-runinfo.outputs.trx-files }}"
          ./test/assert-value-is-empty.sh --name "test-results-truncated output" --value "${{ steps.missing-runinfo.outputs.test-results-truncated }}"
          ./test/assert-value-is-empty.sh --name "status-check-id output" --value "${{ steps.missing-runinfo.outputs.status-check-ids }}"
          ./test/assert-value-is-empty.sh --name "pr-comment-id output" --value "${{ steps.missing-runinfo.outputs.pr-comment-id }}"

      - name: '-------------------------------------------------------------------------------------------------------------'
        run: echo ""
      - name: '                                          TEST 9 - NO TESTS IN FILE                                          '
        run: echo ""

      - name: 9 - When process-dotnet-test-results is called with a file that does not contain test results or test definitions
        if: always()
        id: no-tests
        uses: ./
        with:
          github-token: '${{ secrets.GITHUB_TOKEN }}'
          base-directory: './test/files/no-tests'
          create-results-file: true # Keep this so we have an "actual" output to compare against
          create-status-check: false
          create-pr-comment: false
          timezone: 'America/Denver'

      - name: 9 - Then the action outcome should be success
        if: always()
        run: ./test/assert-values-match.sh --name "step outcome" --expected "success" --actual "${{ steps.no-tests.outcome }}"

      - name: 9 - And the trx-files output should be contain the no-tests.trx file
        if: always()
        run: ./test/assert-values-match.sh --name "trx-files output" --expected "[./test/files/no-tests/no-tests.trx]" --actual "${{ steps.no-tests.outputs.trx-files }}"

      - name: 9 - And the test-outcome output should be Passed because there are no failing tests
        if: always()
        run: ./test/assert-values-match.sh --name "test-outcome output" --expected "Passed" --actual "${{ steps.no-tests.outputs.test-outcome }}"

      - name: 9 - And the test-results-file-path output and env var should be populated with 'test-results.md'
        if: always()
        run: |
          ./test/assert-values-match.sh --name "test-results-file-path output" --expected "${{ github.workspace }}/test-results.md" --actual "${{ steps.no-tests.outputs.test-results-file-path }}"
          ./test/assert-values-match.sh --name "test-results-file-path envVar" --expected "${{ github.workspace }}/test-results.md" --actual "${{ env.TEST_RESULTS_FILE_PATH }}"

      - name: 9 - And the other outputs should be empty because pr comments and status checks are not being created
        if: always()
        run: |
          ./test/assert-value-is-empty.sh --name "test-results-truncated output" --value "${{ steps.no-tests.outputs.test-results-truncated }}"
          ./test/assert-value-is-empty.sh --name "status-check-id output" --value "${{ steps.no-tests.outputs.status-check-ids }}"
          ./test/assert-value-is-empty.sh --name "pr-comment-id output" --value "${{ steps.no-tests.outputs.pr-comment-id }}"

      - name: 9 - And the contents of test-results.md file should match the contents of expected-test-results.md file
        if: always()
        run: |
          # Comparing the test-results.md file will ensure that:
          #  - The correct timezone is used
          #  - The computer name is used for report title when there are no tests
          #  - The test icon is correct when the outcome doesn't match expected scenarios (passed/failed/notexecuted)
          #  - The Duration stats are included in the report
          #  - The Counter stats are included in the report

          expectedFileName="./test/files/no-tests/expected-test-results.md"
          actualFileName="./test-results.md"
          ./test/assert-file-contents-match.sh --expectedFileName $expectedFileName --actualFileName $actualFileName

      - name: '--------------------------------------------------------------------------------------------------------------'
        run: |
          echo ""
          echo "TEST_RESULTS_FILE_PATH=" >> "$GITHUB_ENV"
          rm -f ./test-results.md
      - name: '                                       TEST 10 - NO UNIT TESTS IN FILE                                        '
        run: echo ""

      - name: 10 - When process-dotnet-test-results is called with a file that does not contain unit test results or unit test definitions
        if: always()
        id: no-unit-tests
        uses: ./
        with:
          github-token: '${{ secrets.GITHUB_TOKEN }}'
          base-directory: './test/files/no-unit-tests'
          create-results-file: true # Keep this so we have an "actual" output to compare against
          create-status-check: false
          create-pr-comment: false

      - name: 10 - Then the action outcome should be success
        if: always()
        run: ./test/assert-values-match.sh --name "step outcome" --expected "success" --actual "${{ steps.no-unit-tests.outcome }}"

      - name: 10 - And the trx-files output should be contain the no-unit-tests.trx file
        if: always()
        run: ./test/assert-values-match.sh --name "trx-files output" --expected "[./test/files/no-unit-tests/no-unit-tests.trx]" --actual "${{ steps.no-unit-tests.outputs.trx-files }}"

      - name: 10 - And the test-outcome output should be Passed because there are no failing tests
        if: always()
        run: ./test/assert-values-match.sh --name "test-outcome output" --expected "Passed" --actual "${{ steps.no-unit-tests.outputs.test-outcome }}"

      - name: 10 - And the test-results-file-path output and env var should be populated with 'test-results.md'
        if: always()
        run: |
          ./test/assert-values-match.sh --name "test-results-file-path output" --expected "${{ github.workspace }}/test-results.md" --actual "${{ steps.no-unit-tests.outputs.test-results-file-path }}"
          ./test/assert-values-match.sh --name "test-results-file-path envVar" --expected "${{ github.workspace }}/test-results.md" --actual "${{ env.TEST_RESULTS_FILE_PATH }}"

      - name: 10 - And the other outputs should be empty because pr comments and status checks are not being created
        if: always()
        run: |
          ./test/assert-value-is-empty.sh --name "test-results-truncated output" --value "${{ steps.no-unit-tests.outputs.test-results-truncated }}"
          ./test/assert-value-is-empty.sh --name "status-check-id output" --value "${{ steps.no-unit-tests.outputs.status-check-ids }}"
          ./test/assert-value-is-empty.sh --name "pr-comment-id output" --value "${{ steps.no-unit-tests.outputs.pr-comment-id }}"

      - name: 10 - And the contents of test-results.md file should match the contents of expected-test-results.md file
        if: always()
        run: |
          # Comparing the test-results.md file will ensure that:
          #  - The default timezone is used
          #  - 'Not Found' is used for report title when there are no tests and no _computerName attr present
          #  - The Duration stats are included in the report
          #  - The Counter stats are included in the report

          expectedFileName="./test/files/no-unit-tests/expected-test-results.md"
          actualFileName="./test-results.md"
          ./test/assert-file-contents-match.sh --expectedFileName $expectedFileName --actualFileName $actualFileName

      - name: '--------------------------------------------------------------------------------------------------------------'
        run: |
          echo ""
          echo "TEST_RESULTS_FILE_PATH=" >> "$GITHUB_ENV"
          rm -f ./test-results.md
      - name: '                                            TEST 11 - SINGLE TEST                                             '
        run: echo ""

      - name: 11 - When process-dotnet-test-results is called with a file that reports a single test
        if: always()
        id: single-test
        uses: ./
        with:
          github-token: '${{ secrets.GITHUB_TOKEN }}'
          base-directory: './test/files/single-test'
          create-results-file: true # Keep this so we have an "actual" output to compare against
          create-status-check: false
          create-pr-comment: false

      - name: 11 - Then the action outcome should be success
        if: always()
        run: ./test/assert-values-match.sh --name "step outcome" --expected "success" --actual "${{ steps.single-test.outcome }}"

      - name: 11 - And the outputs should indicate a success happened
        if: always()
        run: |
          # Verify the trx-files list matches what we expect
          ./test/assert-values-match.sh --name "trx-files output" --expected "[./test/files/single-test/single-test.trx]" --actual "${{ steps.single-test.outputs.trx-files }}"

          # Verify the test-outcome is passed
          ./test/assert-values-match.sh --name "test-outcome output" --expected "Passed" --actual "${{ steps.single-test.outputs.test-outcome }}"

          # Verify the test-results-file-path output and env var should be populated with 'test-results.md'
          ./test/assert-values-match.sh --name "test-results-file-path output" --expected "${{ github.workspace }}/test-results.md" --actual "${{ steps.single-test.outputs.test-results-file-path }}"
          ./test/assert-values-match.sh --name "test-results-file-path envVar" --expected "${{ github.workspace }}/test-results.md" --actual "${{ env.TEST_RESULTS_FILE_PATH }}"

          # Verify this output is not set because we aren't creating a PR comment or status check
          ./test/assert-value-is-empty.sh --name "test-results-truncated output" --value "${{ steps.single-test.outputs.test-results-truncated }}"
          ./test/assert-value-is-empty.sh --name "status-check-id output" --value "${{ steps.single-test.outputs.status-check-ids }}"
          ./test/assert-value-is-empty.sh --name "pr-comment-id output" --value "${{ steps.single-test.outputs.pr-comment-id }}"

      - name: 11 - And the contents of test-results.md file should match the contents of expected-test-results.md file
        if: always()
        run: |
          # Comparing the test-results.md file will ensure that:
          #  - The default timezone is used
          #  - The dll name is used for report title when a report title filter is not specified
          #  - The Duration stats are included in the report
          #  - The Counter stats are included in the report

          expectedFileName="./test/files/single-test/expected-test-results.md"
          actualFileName="./test-results.md"
          ./test/assert-file-contents-match.sh --expectedFileName $expectedFileName --actualFileName $actualFileName

      - name: '--------------------------------------------------------------------------------------------------------------'
        run: |
          echo ""
          echo "TEST_RESULTS_FILE_PATH=" >> "$GITHUB_ENV"
          rm -f ./test-results.md
      - name: '                                           TEST 12 - MULTIPLE TESTS                                           '
        run: echo ""

      - name: 12 - When process-dotnet-test-results is called with a file that has multiple tests and a report title filter
        if: always()
        id: multiple-tests
        uses: ./
        with:
          github-token: '${{ secrets.GITHUB_TOKEN }}'
          base-directory: './test/files/multiple-tests'
          create-results-file: true # Keep this so we have an "actual" output to compare against
          create-status-check: false
          create-pr-comment: false
          report-title-filter: 'Tests'

      - name: 12 - Then the action outcome should be success
        if: always()
        run: ./test/assert-values-match.sh --name "step outcome" --expected "success" --actual "${{ steps.multiple-tests.outcome }}"

      - name: 12 - And the outputs should indicate a success happened
        if: always()
        run: |
          # Verify the trx-files list matches what we expect
          ./test/assert-values-match.sh --name "trx-files output" --expected "[./test/files/multiple-tests/multiple-tests.trx]" --actual "${{ steps.multiple-tests.outputs.trx-files }}"

          # Verify the test-outcome is passed
          ./test/assert-values-match.sh --name "test-outcome output" --expected "Passed" --actual "${{ steps.multiple-tests.outputs.test-outcome }}"

          # Verify the test-results-file-path output and env var should be populated with 'test-results.md'
          ./test/assert-values-match.sh --name "test-results-file-path output" --expected "${{ github.workspace }}/test-results.md" --actual "${{ steps.multiple-tests.outputs.test-results-file-path }}"
          ./test/assert-values-match.sh --name "test-results-file-path envVar" --expected "${{ github.workspace }}/test-results.md" --actual "${{ env.TEST_RESULTS_FILE_PATH }}"

          # Verify this output is not set because we aren't creating a PR comment or status check
          ./test/assert-value-is-empty.sh --name "test-results-truncated output" --value "${{ steps.multiple-tests.outputs.test-results-truncated }}"
          ./test/assert-value-is-empty.sh --name "status-check-id output" --value "${{ steps.multiple-tests.outputs.status-check-ids }}"
          ./test/assert-value-is-empty.sh --name "pr-comment-id output" --value "${{ steps.multiple-tests.outputs.pr-comment-id }}"

      - name: 12 - And the contents of test-results.md file should match the contents of expected-test-results.md file
        if: always()
        run: |
          # Comparing the test-results.md file will ensure that:
          #  - The default timezone is used
          #  - The report title is simplified when a report title filter is specified
          #  - The Duration stats are included in the report
          #  - The Counter stats are included in the report

          expectedFileName="./test/files/multiple-tests/expected-test-results.md"
          actualFileName="./test-results.md"
          ./test/assert-file-contents-match.sh --expectedFileName $expectedFileName --actualFileName $actualFileName

      - name: '--------------------------------------------------------------------------------------------------------------'
        run: |
          echo ""
          echo "TEST_RESULTS_FILE_PATH=" >> "$GITHUB_ENV"
          rm -f ./test-results.md
      - name: '                                             TEST 13 - MULTIPLE TRX                                           '
        run: echo ""

      - name: 13 - When process-dotnet-test-results is called with multiple passing trx files
        if: always()
        id: multiple-trx
        uses: ./
        with:
          github-token: '${{ secrets.GITHUB_TOKEN }}'
          base-directory: './test/files/multiple-trx'
          create-results-file: true # Keep this so we have an "actual" output to compare against
          create-status-check: false
          create-pr-comment: false

      - name: 13 - Then the action outcome should be success
        if: always()
        run: ./test/assert-values-match.sh --name "step outcome" --expected "success" --actual "${{ steps.multiple-trx.outcome }}"

      - name: 13 - And the outputs should indicate a success happened
        if: always()
        run: |
          # Verify the trx-files list matches what we expect
          fidget="./test/files/multiple-trx/fidget.trx"
          widget="./test/files/multiple-trx/widget.trx"
          ./test/assert-values-match.sh --name "trx-files output" --expected "[$fidget,$widget]" --actual "${{ steps.multiple-trx.outputs.trx-files }}"

          # Verify the test-outcome is passed
          ./test/assert-values-match.sh --name "test-outcome output" --expected "Passed" --actual "${{ steps.multiple-trx.outputs.test-outcome }}"

          # Verify the test-results-file-path output and env var should be populated with 'test-results.md'
          ./test/assert-values-match.sh --name "test-results-file-path output" --expected "${{ github.workspace }}/test-results.md" --actual "${{ steps.multiple-trx.outputs.test-results-file-path }}"
          ./test/assert-values-match.sh --name "test-results-file-path envVar" --expected "${{ github.workspace }}/test-results.md" --actual "${{ env.TEST_RESULTS_FILE_PATH }}"

          # Verify this output is not set because we aren't creating a PR comment or status check
          ./test/assert-value-is-empty.sh --name "test-results-truncated output" --value "${{ steps.multiple-trx.outputs.test-results-truncated }}"
          ./test/assert-value-is-empty.sh --name "pr-comment-id output" --value "${{ steps.multiple-trx.outputs.pr-comment-id }}"
          ./test/assert-value-is-empty.sh --name "status-check-id output" --value "${{ steps.multiple-trx.outputs.status-check-ids }}"

      - name: 13 - And the contents of test-results.md file should match the contents of expected-test-results.md file
        if: always()
        run: |
          # Comparing the test-results.md file will ensure that:
          #  - The default timezone is used
          #  - The Duration stats are included in the report
          #  - The Counter stats are included in the report
          #  - There are multiple sections when multiple trx files are processed

          expectedFileName="./test/files/multiple-trx/expected-test-results.md"
          actualFileName="./test-results.md"
          ./test/assert-file-contents-match.sh --expectedFileName $expectedFileName --actualFileName $actualFileName

      - name: '--------------------------------------------------------------------------------------------------------------'
        run: |
          echo ""
          echo "TEST_RESULTS_FILE_PATH=" >> "$GITHUB_ENV"
          rm -f ./test-results.md
      - name: '                                             TEST 14 - FAILING TEST                                           '
        run: echo ""

      - name: 14 - When process-dotnet-test-results is called with a failing trx file
        if: always()
        id: failing-test
        uses: ./
        with:
          github-token: '${{ secrets.GITHUB_TOKEN }}'
          base-directory: './test/files/failing-test'
          create-results-file: true # Keep this so we have an "actual" output to compare against
          create-status-check: false
          create-pr-comment: false

      - name: 14 - Then the action outcome should be success
        if: always()
        run: ./test/assert-values-match.sh --name "step outcome" --expected "success" --actual "${{ steps.failing-test.outcome }}"

      - name: 14 - And the outputs should indicate a success happened
        if: always()
        run: |
          # Verify the trx-files list matches what we expect
          failure="./test/files/failing-test/failure.trx"
          ./test/assert-values-match.sh --name "trx-files output" --expected "[$failure]" --actual "${{ steps.failing-test.outputs.trx-files }}"

          # Verify the test-outcome is Failed
          ./test/assert-values-match.sh --name "test-outcome output" --expected "Failed" --actual "${{ steps.failing-test.outputs.test-outcome }}"

          # Verify the test-results-file-path output and env var should be populated with 'test-results.md'
          ./test/assert-values-match.sh --name "test-results-file-path output" --expected "${{ github.workspace }}/test-results.md" --actual "${{ steps.failing-test.outputs.test-results-file-path }}"
          ./test/assert-values-match.sh --name "test-results-file-path envVar" --expected "${{ github.workspace }}/test-results.md" --actual "${{ env.TEST_RESULTS_FILE_PATH }}"

          # Verify this output is not set because we aren't creating a PR comment or status check
          ./test/assert-value-is-empty.sh --name "test-results-truncated output" --value "${{ steps.failing-test.outputs.test-results-truncated }}"
          ./test/assert-value-is-empty.sh --name "pr-comment-id output" --value "${{ steps.failing-test.outputs.pr-comment-id }}"
          ./test/assert-value-is-empty.sh --name "status-check-id output" --value "${{ steps.failing-test.outputs.status-check-ids }}"

      - name: 14 - And the contents of test-results.md file should match the contents of expected-test-results.md file
        if: always()
        run: |
          # Comparing the test-results.md file will ensure that:
          #  - The default timezone is used
          #  - The badge is affected by failures
          #  - The Duration stats are included in the report
          #  - The Counter stats are included in the report
          #  - The failure details are included

          expectedFileName="./test/files/failing-test/expected-test-results.md"
          actualFileName="./test-results.md"
          ./test/assert-file-contents-match.sh --expectedFileName $expectedFileName --actualFileName $actualFileName

      - name: '--------------------------------------------------------------------------------------------------------------'
        run: echo ""

  test-status-checks:
    runs-on: ubuntu-latest
    if: 1 == 2
    env:
      NO_FAILURES_DIR: './test/files/multiple-trx'
      FAILURES_DIR: './test/files/failing-test'

    steps:
      - name: '-------------------------------------------------------------------------------------------------------------'
        run: echo ""
      - name: '                                                    SETUP                                                    '
        run: echo ""

      - name: Setup - Fail test job if fork
        run: |
          if [ "${{ github.event.pull_request.head.repo.fork }}" == "true" ]; then
            echo "This test job requires the `checks: write` scope on the GITHUB_TOKEN which PRs from forks do not have.  Before this PR can be merged, the tests should be run on an intermediate branch created by repository owners."
            exit 1
          fi

      - name: Setup - Checkout the action
        uses: actions/checkout@v4

      - name: '-------------------------------------------------------------------------------------------------------------'
        run: echo ""
      - name: '                                     TEST 15 - STATUS CHECK - NO FAILURES                                    '
        run: echo ""

      - name: 15 - When process-dotnet-test-results is called with no failures in multiple trx files
        if: always()
        id: no-failures
        uses: ./
        with:
          github-token: '${{ secrets.GITHUB_TOKEN }}'
          base-directory: ${{ env.NO_FAILURES_DIR }}
          create-results-file: true # Keep this so we have an "actual" output to compare against
          create-status-check: true
          create-pr-comment: false

      - name: 15 - Then the action outcome should be success
        if: always()
        run: ./test/assert-values-match.sh --name "step outcome" --expected "success" --actual "${{ steps.no-failures.outcome }}"

      - name: 15 - And the status-check-ids output should be populated
        if: always()
        run: ./test/assert-value-is-not-empty.sh --name "status-check-ids output" --value "${{ steps.no-failures.outputs.status-check-ids }}"

      - name: 15 - And the test-outcome output should be Passed
        if: always()
        run: ./test/assert-values-match.sh --name "test-outcome output" --expected "Passed" --actual "${{ steps.no-failures.outputs.test-outcome }}"

      - name: 15 - And the status check should match the inputs
        if: always()
        uses: actions/github-script@v6
        with:
          script: |
            const fs = require('fs');
            const assertStatusCheckExists = require('./test/assert-status-checks-exist.js');
            const assertStatusCheckMatchesExpectations = require('./test/assert-status-check-matches-expectations.js');

            const checkIds = '${{ steps.no-failures.outputs.status-check-ids }}';
            const actualStatusChecks = await assertStatusCheckExists(github, core, checkIds);
            const expectedBody = fs.readFileSync('./test-results.md', 'utf8');

            const expectedFidgetValues = {
              name: 'status check - dotnet unit tests (fidget.tests)',
              status: 'completed',
              conclusion: 'success',
              title: 'FIDGET.TESTS',
              text: expectedBody
            };
            const actualFidgetCheck = actualStatusChecks.find(check => check.name.includes('fidget'));
            assertStatusCheckMatchesExpectations(core, actualFidgetCheck, expectedFidgetValues);

            const expectedWidgetValues = {
              name: 'status check - dotnet unit tests (widget.tests)',
              status: 'completed',
              conclusion: 'success',
              title: 'WIDGET.TESTS',
              text: expectedBody
            };
            const actualWidgetCheck = actualStatusChecks.find(check => check.name.includes('widget'));
            assertStatusCheckMatchesExpectations(core, actualWidgetCheck, expectedWidgetValues);

      - name: '-------------------------------------------------------------------------------------------------------------'
        run: echo ""
      - name: '                                   TEST 16 - STATUS CHECK - IGNORE FAILURES                                  '
        run: echo ""

      - name: 16 - When process-dotnet-test-results is called with test failures & ignore-test-failures=true
        if: always()
        id: ignore-failures
        uses: ./
        with:
          github-token: '${{ secrets.GITHUB_TOKEN }}'
          base-directory: ${{ env.FAILURES_DIR }}
          create-results-file: true # Keep this so we have an "actual" output to compare against
          create-status-check: true
          ignore-test-failures: true
          create-pr-comment: false

      - name: 16 - Then the action outcome should be success
        if: always()
        run: ./test/assert-values-match.sh --name "step outcome" --expected "success" --actual "${{ steps.ignore-failures.outcome }}"

      - name: 16 - And the status-check-ids output should be populated
        if: always()
        run: ./test/assert-value-is-not-empty.sh --name "status-check-ids output" --value "${{ steps.ignore-failures.outputs.status-check-ids }}"

      - name: 16 - And the test-outcome output should be Failed
        if: always()
        run: ./test/assert-values-match.sh --name "test-outcome output" --expected "Failed" --actual "${{ steps.ignore-failures.outputs.test-outcome }}"

      - name: 16 - And the status check should match the inputs
        if: always()
        uses: actions/github-script@v6
        with:
          script: |
            const fs = require('fs');
            const assertStatusCheckExists = require('./test/assert-status-checks-exist.js');
            const assertStatusCheckMatchesExpectations = require('./test/assert-status-check-matches-expectations.js');

            const checkIds = '${{ steps.ignore-failures.outputs.status-check-ids }}';
            const actualStatusChecks = await assertStatusCheckExists(github, core, checkIds);
            const expectedBody = fs.readFileSync('./test-results.md', 'utf8');

            const expectedValues = {
              name: 'status check - dotnet unit tests (widget.tests)',
              status: 'completed',
              conclusion: 'neutral',
              title: 'WIDGET.TESTS',
              text: expectedBody
            };
            const actualCheck = actualStatusChecks.find(check => check.name.includes('widget'));
            assertStatusCheckMatchesExpectations(core, actualCheck, expectedValues);

      - name: '-------------------------------------------------------------------------------------------------------------'
        run: echo ""
      - name: '                                    TEST 17 - STATUS CHECK - ACK FAILURES                                    '
        run: echo ""

      - name: 17 - When process-dotnet-test-results is called with test failures & ignore-test-failures=false
        if: always()
        id: ack-failures
        uses: ./
        with:
          github-token: '${{ secrets.GITHUB_TOKEN }}'
          base-directory: ${{ env.FAILURES_DIR }}
          create-results-file: true # Keep this so we have an "actual" output to compare against
          create-status-check: true
          ignore-test-failures: false
          create-pr-comment: false

      - name: 17 - Then the action outcome should be success
        if: always()
        run: ./test/assert-values-match.sh --name "step outcome" --expected "success" --actual "${{ steps.ack-failures.outcome }}"

      - name: 17 - And the status-check-ids output should be populated
        if: always()
        run: ./test/assert-value-is-not-empty.sh --name "status-check-ids output" --value "${{ steps.ack-failures.outputs.status-check-ids }}"

      - name: 17 - And the test-outcome output should be Failed
        if: always()
        run: ./test/assert-values-match.sh --name "test-outcome output" --expected "Failed" --actual "${{ steps.ack-failures.outputs.test-outcome }}"

      - name: 17 - And the status check should match the inputs
        if: always()
        uses: actions/github-script@v6
        with:
          script: |
            const fs = require('fs');
            const assertStatusCheckExists = require('./test/assert-status-checks-exist.js');
            const assertStatusCheckMatchesExpectations = require('./test/assert-status-check-matches-expectations.js');

            const checkIds = '${{ steps.ack-failures.outputs.status-check-ids }}';
            const actualStatusChecks = await assertStatusCheckExists(github, core, checkIds);
            const expectedBody = fs.readFileSync('./test-results.md', 'utf8');

            const expectedValues = {
              name: 'status check - dotnet unit tests (widget.tests)',
              status: 'completed',
              conclusion: 'failure',
              title: 'WIDGET.TESTS',
              text: expectedBody
            };
            const actualCheck = actualStatusChecks.find(check => check.name.includes('widget'));
            assertStatusCheckMatchesExpectations(core, actualCheck, expectedValues);

      - name: '-------------------------------------------------------------------------------------------------------------'
        run: echo ""

  test-pr-comments:
    runs-on: ubuntu-latest
    env:
      NO_FAILURES_DIR: './test/files/multiple-trx'
      TRUNCATE_DIR: './test/files/truncate'
      EXISTING_COMMENT_ID: ''
      COMMENT_IDENTIFIER: 'existing-comment-${{ github.run_id }}'

    steps:
      - name: '-------------------------------------------------------------------------------------------------------------'
        run: echo ""
      - name: '                                                    SETUP                                                    '
        run: echo ""

      - name: Setup - Fail test job if fork
        run: |
          if [ "${{ github.event.pull_request.head.repo.fork }}" == "true" ]; then
            echo "This test job requires the `pull_request: write` scope on the GITHUB_TOKEN which PRs from forks do not have.  Before this PR can be merged, the tests should be run on an intermediate branch created by repository owners."
            exit 1
          fi

      - name: Setup - Checkout the action
        uses: actions/checkout@v4

      - name: Setup - Create a comment that can be updated
        if: always()
        uses: actions/github-script@v6
        with:
          script: |
            await github.rest.issues.createComment({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: context.issue.number,
              body: '<!-- im-open/process-dotnet-test-results ${{ env.COMMENT_IDENTIFIER }} -->\nThis comment will be replaced soon.'
            })
            .then(response => {
              core.exportVariable('EXISTING_COMMENT_ID', response.data.id);
            })
            .catch(error => {
              core.setFailed(`An error occurred in the setup step while creating a comment: ${error.message}`);
            });
            await new Promise(r => setTimeout(r, 5 * 1000));

      - name: '-------------------------------------------------------------------------------------------------------------'
        run: echo ""
      - name: '                              TEST 18 - PR COMMENT - UPDATE W/ MATCHING PREFIX                               '
        run: echo ""

      - name: 18 - When process-dotnet-test-results is called with updateComment=true and there is a comment with matching prefix
        if: always()
        id: update-with-matching-prefix
        uses: ./
        with:
          github-token: '${{ secrets.GITHUB_TOKEN }}'
          base-directory: ${{ env.NO_FAILURES_DIR }}
          create-results-file: true # Keep this so we can compare the comment contents to the expected contents
          create-status-check: false
          create-pr-comment: true
          update-comment-if-one-exists: true
          comment-identifier: ${{ env.COMMENT_IDENTIFIER }}

      - name: 18 - Then the action outcome should be success
        if: always()
        run: ./test/assert-values-match.sh --name "step outcome" --expected "success" --actual "${{ steps.update-with-matching-prefix.outcome }}"

      - name: 18 - And the pr-comment-id output should match the existing comment id
        if: always()
        run: ./test/assert-values-match.sh --name "pr-comment-id output" --expected "${{ env.EXISTING_COMMENT_ID }}" --actual "${{ steps.update-with-matching-prefix.outputs.pr-comment-id }}"

      - name: 18 - And the test-results-truncated output should be false
        if: always()
        run: ./test/assert-values-match.sh --name "test-results-truncated output" --expected "false" --actual "${{ steps.update-with-matching-prefix.outputs.test-results-truncated }}"

      - name: 18 - And the pr-comment should match the match the expected values
        if: always()
        uses: actions/github-script@v6
        with:
          script: |
            const fs = require('fs');
            const assertCommentExists = require('./test/assert-pr-comment-exists.js');
            const assertCommentMatchesExpectations = require('./test/assert-pr-comment-matches-expectations.js');

            const commentId = '${{ steps.update-with-matching-prefix.outputs.pr-comment-id }}';
            const actualComment = await assertCommentExists(github, core, commentId);

            const expectedBody = fs.readFileSync('./test-results.md', 'utf8');
            const expectedPrefix = '<!-- im-open/process-dotnet-test-results ${{ env.COMMENT_IDENTIFIER }} -->';
            const expectedComment = {
              prefixAndBody: `${expectedPrefix}\n${expectedBody}`,
              action: 'updated'
            };
            assertCommentMatchesExpectations(core, actualComment, expectedComment);

      - name: '-------------------------------------------------------------------------------------------------------------'
        run: echo ""
      - name: '                              TEST 19 - PR COMMENT - UPDATE W/O MATCHING PREFIX                              '
        run: echo ""

      - name: 19 - When process-dotnet-test-results is called with updateComment=true but there is no comment with matching prefix
        if: always()
        id: update-without-matching-prefix
        uses: ./
        with:
          github-token: '${{ secrets.GITHUB_TOKEN }}'
          base-directory: ${{ env.NO_FAILURES_DIR }}
          create-results-file: true # Keep this so we can compare the comment contents to the expected contents
          create-status-check: false
          create-pr-comment: true
          update-comment-if-one-exists: true
          comment-identifier: 'different-identifier-${{ github.run_id }}'

      - name: 19 - Then the action outcome should be success
        if: always()
        run: ./test/assert-values-match.sh --name "step outcome" --expected "success" --actual "${{ steps.update-without-matching-prefix.outcome }}"

      - name: 19 - And the pr-comment-id output should be different than the existing comment id
        if: always()
        run: ./test/assert-values-do-not-match.sh --name "pr-comment-id output" --value1 "${{ env.EXISTING_COMMENT_ID }}" --value2 "${{ steps.update-without-matching-prefix.outputs.pr-comment-id }}"

      - name: 19 - And the test-results-truncated output should be false
        if: always()
        run: ./test/assert-values-match.sh --name "test-results-truncated output" --expected "false" --actual "${{ steps.update-without-matching-prefix.outputs.test-results-truncated }}"

      - name: 19 - And the pr-comment should match the expected values
        if: always()
        uses: actions/github-script@v6
        with:
          script: |
            const fs = require('fs');
            const assertCommentExists = require('./test/assert-pr-comment-exists.js');
            const assertCommentMatchesExpectations = require('./test/assert-pr-comment-matches-expectations.js');

            const commentId = '${{ steps.update-without-matching-prefix.outputs.pr-comment-id }}';
            const actualComment = await assertCommentExists(github, core, commentId);

            const expectedBody = fs.readFileSync('./test-results.md', 'utf8');
            const expectedPrefix = '<!-- im-open/process-dotnet-test-results different-identifier-${{ github.run_id }} -->';
            const expectedComment = {
              prefixAndBody: `${expectedPrefix}\n${expectedBody}`,
              action: 'created'
            };
            assertCommentMatchesExpectations(core, actualComment, expectedComment);

      - name: '-------------------------------------------------------------------------------------------------------------'
        run: echo ""
      - name: '                                       TEST 20 - PR COMMENT - NO UPDATE                                      '
        run: echo ""

      - name: 20 - When process-dotnet-test-results is called with updateComment=false
        if: always()
        id: matching-prefix-no-update
        uses: ./
        with:
          github-token: '${{ secrets.GITHUB_TOKEN }}'
          base-directory: ${{ env.NO_FAILURES_DIR }}
          create-results-file: true # Keep this so we can compare the comment contents to the expected contents
          create-status-check: false
          create-pr-comment: true
          update-comment-if-one-exists: false

      - name: 20 - Then the action outcome should be success
        if: always()
        run: ./test/assert-values-match.sh --name "step outcome" --expected "success" --actual "${{ steps.matching-prefix-no-update.outcome }}"

      - name: 20 - And the pr-comment-id output should be different than the existing comment id
        if: always()
        run: ./test/assert-values-do-not-match.sh --name "pr-comment-id output" --value1 "${{ env.EXISTING_COMMENT_ID }}" --value2 "${{ steps.matching-prefix-no-update.outputs.pr-comment-id }}"

      - name: 20 - And the test-results-truncated output should be false
        if: always()
        run: ./test/assert-values-match.sh --name "test-results-truncated output" --expected "false" --actual "${{ steps.matching-prefix-no-update.outputs.test-results-truncated }}"

      - name: 20 - And the pr-comment should match the expected values
        if: always()
        uses: actions/github-script@v6
        with:
          script: |
            const fs = require('fs');
            const assertCommentExists = require('./test/assert-pr-comment-exists.js');
            const assertCommentMatchesExpectations = require('./test/assert-pr-comment-matches-expectations.js');

            const commentId = '${{ steps.matching-prefix-no-update.outputs.pr-comment-id }}';
            const actualComment = await assertCommentExists(github, core, commentId);

            const expectedBody = fs.readFileSync('./test-results.md', 'utf8');
            const expectedPrefix = '<!-- im-open/process-dotnet-test-results  -->';
            const expectedComment = {
              prefixAndBody: `${expectedPrefix}\n${expectedBody}`,
              action: 'created'
            };
            assertCommentMatchesExpectations(core, actualComment, expectedComment);

      - name: '-------------------------------------------------------------------------------------------------------------'
        run: echo ""
      - name: '                                       TEST 21 - PR COMMENT - TRUNCATE                                       '
        run: echo ""

      - name: 21 - When process-dotnet-test-results is called with a large comment that needs to be truncated
        if: always()
        id: truncate
        uses: ./
        with:
          github-token: '${{ secrets.GITHUB_TOKEN }}'
          base-directory: ${{ env.TRUNCATE_DIR }}
          create-results-file: true # Keep this so we can compare the comment contents to the expected contents
          create-status-check: false
          create-pr-comment: true
          update-comment-if-one-exists: true
          comment-identifier: ${{ env.COMMENT_IDENTIFIER }}

      - name: 21 - Then the action outcome should be success
        if: always()
        run: ./test/assert-values-match.sh --name "step outcome" --expected "success" --actual "${{ steps.truncate.outcome }}"

      - name: 21 - And the pr-comment-id output should match the existing comment id
        if: always()
        run: ./test/assert-values-match.sh --name "pr-comment-id output" --expected "${{ env.EXISTING_COMMENT_ID }}" --actual "${{ steps.truncate.outputs.pr-comment-id }}"

      - name: 21 - And the test-results-truncated output should be true
        if: always()
        run: ./test/assert-values-match.sh --name "test-results-truncated output" --expected "true" --actual "${{ steps.truncate.outputs.test-results-truncated }}"

      - name: 21 - And the pr-comment should match the expected values
        if: always()
        uses: actions/github-script@v6
        with:
          script: |
            const fs = require('fs');
            const assertCommentExists = require('./test/assert-pr-comment-exists.js');
            const assertCommentMatchesExpectations = require('./test/assert-pr-comment-matches-expectations.js');

            const commentId = '${{ steps.truncate.outputs.pr-comment-id }}';
            const actualComment = await assertCommentExists(github, core, commentId);

            const expectedBody = fs.readFileSync('./test-results.md', 'utf8');
            const expectedPrefix = '<!-- im-open/process-dotnet-test-results ${{ env.COMMENT_IDENTIFIER }} -->';
            const expectedComment = {
              prefixAndBody: `${expectedPrefix}\nTest results truncated due to character limit. See full report in output. \n${expectedBody}`,
              action: 'updated'
            };

            assertCommentMatchesExpectations(core, actualComment, expectedComment);

      - name: '-------------------------------------------------------------------------------------------------------------'
        run: echo ""
      - name: '                                                   TEARDOWN                                                  '
        run: echo ""

      - name: Teardown - Delete PR Comments
        if: always()
        uses: actions/github-script@v6
        with:
          #github-token: ${{ secrets.PIPELINE_BOT_PAT }}
          script: |
            const fs = require('fs');
            const deletePrComment = require('./test/delete-pr-comment.js');

            await deletePrComment(github, core, '${{ secrets.PIPELINE_BOT_PAT }}', '${{ env.EXISTING_COMMENT_ID }}');
            await deletePrComment(github, core, '${{ secrets.PIPELINE_BOT_PAT }}', '${{ steps.matching-prefix-no-update.outputs.pr-comment-id }}');
            await deletePrComment(github, core, '${{ secrets.PIPELINE_BOT_PAT }}', '${{ steps.update-without-matching-prefix.outputs.pr-comment-id }}');


      - name: '-------------------------------------------------------------------------------------------------------------'
        run: echo ""
